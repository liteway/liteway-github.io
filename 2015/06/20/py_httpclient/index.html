<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Python HTTP Client Lib | 骆驼的乌托邦</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="使用Python中的HTTP Client库来爬取网页的访问十分方便，但众多的库可能让使用者感觉杂乱无章，本文总结了Python中几个常见HTTP库的使用方式，以便根据实际需求来选择合适的库。">
<meta property="og:type" content="article">
<meta property="og:title" content="Python HTTP Client Lib">
<meta property="og:url" content="https://github.com/liteway/liteway.github.io/2015/06/20/py_httpclient/index.html">
<meta property="og:site_name" content="骆驼的乌托邦">
<meta property="og:description" content="使用Python中的HTTP Client库来爬取网页的访问十分方便，但众多的库可能让使用者感觉杂乱无章，本文总结了Python中几个常见HTTP库的使用方式，以便根据实际需求来选择合适的库。">
<meta property="og:updated_time" content="2015-08-08T15:39:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python HTTP Client Lib">
<meta name="twitter:description" content="使用Python中的HTTP Client库来爬取网页的访问十分方便，但众多的库可能让使用者感觉杂乱无章，本文总结了Python中几个常见HTTP库的使用方式，以便根据实际需求来选择合适的库。">
  
    <link rel="alternative" href="/atom.xml" title="骆驼的乌托邦" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico">
  
  <link href="//fonts.useso.com/css?family=Inconsolata:400,700|Open+Sans:700,400" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">骆驼的乌托邦
          
          </a>
        </h1>
      </div>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/liteway/liteway.github.io"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main"><article id="post-py_httpclient" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/20/py_httpclient/" class="article-date">
  <time datetime="2015-06-20T15:00:00.000Z" itemprop="datePublished">2015-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Python HTTP Client Lib
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用Python中的HTTP Client库来爬取网页的访问十分方便，但众多的库可能让使用者感觉杂乱无章，本文总结了Python中几个常见HTTP库的使用方式，以便根据实际需求来选择合适的库。<a id="more"></a></p>
<h2 id="urllib">urllib</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">urllib<span class="built_in">.</span>urlopen(url, <span class="built_in">data</span><span class="subst">=</span><span class="literal">None</span>, proxies<span class="subst">=</span><span class="literal">None</span>) 等于：</span><br><span class="line">    opener <span class="subst">=</span> urllib<span class="built_in">.</span>FancyURLopener(proxies<span class="subst">=</span><span class="literal">None</span>)</span><br><span class="line">    opener<span class="built_in">.</span>open(url, <span class="built_in">data</span><span class="subst">=</span><span class="literal">None</span>)</span><br><span class="line">FancyURLopener继承自URLopener，实现了一些异常处理。</span><br><span class="line">proxies <span class="subst">=</span> &#123;<span class="string">'http'</span>: <span class="string">'http://proxy.example.com:8080/'</span>&#125;</span><br><span class="line"></span><br><span class="line">GET Method:</span><br><span class="line"><span class="keyword">params</span> <span class="subst">=</span> urllib<span class="built_in">.</span>urlencode(&#123;<span class="string">'arg1'</span>: arg1_value, <span class="string">'arg2'</span>: arg2_value&#125;)</span><br><span class="line">f <span class="subst">=</span> urllib<span class="built_in">.</span>urlopen(<span class="string">"http://www.xxx.com/query?%s"</span> <span class="subst">%</span><span class="keyword">params</span>)</span><br><span class="line"></span><br><span class="line">POST Method:</span><br><span class="line"><span class="keyword">params</span> <span class="subst">=</span> urllib<span class="built_in">.</span>urlencode(&#123;<span class="string">'arg1'</span>: arg1_value, <span class="string">'arg2'</span>: arg2_value&#125;)</span><br><span class="line">f <span class="subst">=</span> urllib<span class="built_in">.</span>urlopen(<span class="string">"http://www.xxx.com"</span>, <span class="keyword">params</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Return</span> Value:</span><br><span class="line">返回值f可以作为类似文件句柄来处理</span><br><span class="line">f<span class="built_in">.</span>read() 获取页面内容</span><br><span class="line">f<span class="built_in">.</span>getcode() 获取HTTP响应码</span><br><span class="line">f<span class="built_in">.</span>getinfo() 获取url的meta信息</span><br><span class="line">f<span class="built_in">.</span>geturl() 获取最终的url，由于urlopen会自动处理重定向，可以与原始url比较来判断是否有Redirect动作</span><br></pre></td></tr></table></figure>
<p>urllib可以使用urlencode来编码发送的数据，但不允许使用自定义的request header。</p>
<h2 id="urllib2">urllib2</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">urllib2.urlopen(url, <span class="type">data</span>=<span class="type">None</span>, timeout=<span class="keyword">default</span>) 等于：</span><br><span class="line">    opener = urllib2.build_opener(*handler) -&gt; urllib2.OpenerDirector()</span><br><span class="line">    opener.open(url, <span class="type">data</span>=<span class="type">None</span>, timeout=<span class="keyword">default</span>)</span><br><span class="line">    or</span><br><span class="line">    opener = urllib2.build_opener(*handler)</span><br><span class="line">    urllib2.install_opener(opener) #将修改默认的opener全局变量</span><br><span class="line">    urllib2.open(url, <span class="type">data</span>=<span class="type">None</span>, timeout=<span class="keyword">default</span>)</span><br><span class="line"></span><br><span class="line">可以通过构造Request对象来使用自定义header，例如伪造User-Agent，设置Content-<span class="keyword">Type</span>等；<span class="type">data</span>需要用urllib.urlencode来编码。 </span><br><span class="line">常见的Content-<span class="keyword">Type</span>: application/xml, application/json, application/x-www-<span class="keyword">form</span>-urlencoded(web <span class="keyword">form</span>)</span><br><span class="line">req = urllib2.Request(url, <span class="type">data</span>=<span class="type">None</span>, headers=&#123;&#125;)</span><br><span class="line">f = urllib2.urlopen(req)</span><br><span class="line">返回值与urllib类型一致</span><br><span class="line"></span><br><span class="line"><span class="keyword">Use</span> Proxy:</span><br><span class="line">proxies = &#123;<span class="string">'http'</span>: <span class="string">'http://proxy.example.com:8080/'</span>&#125;</span><br><span class="line">proxy_handler = urllib2.ProxyHandler(proxies=<span class="type">None</span>) #proxies为&#123;&#125;则不设置proxy</span><br><span class="line">opener = urllib2.build_opener(proxy_handler)</span><br><span class="line">urllib2.install_opener(opener)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Use</span> Timeout:</span><br><span class="line">没有设置timeout的接口时，可以通过socket的timeout来设置</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">socket.setdefaulttimeout(seconds)</span><br><span class="line"></span><br><span class="line">Response Code:</span><br><span class="line">通过使用异常机制来获取非<span class="number">200</span>响应码</span><br><span class="line">try:</span><br><span class="line">    response = urllib2.urlopen(url)</span><br><span class="line">except urllib2.HTTPError, e:</span><br><span class="line">    <span class="built_in">print</span> e.code</span><br></pre></td></tr></table></figure>
<p>urllib2允许自定义header，但需要使用urllib.urlencode来编码发送的数据。</p>
<h2 id="httplib">httplib</h2><p>urllib和urllib2都使用了httplib来处理http/https client连接，与http server通信，在python3中该模块重命名为http.client。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">conn = httplib.HTTPConnection(host, port=None, <span class="keyword">strict</span>=None, timeout=<span class="keyword">default</span>, source_address=None) </span><br><span class="line">*<span class="keyword">strict</span>默认为<span class="keyword">false</span>，为<span class="keyword">True</span>时表示在response中的状态行无法解析时返回BadStatusLine异常；source_address为(host, port)*</span><br><span class="line">conn = httplib.HTTPSConnection(host, port=None, key_file=None, cert_file=None, <span class="keyword">strict</span>=None, timeout=<span class="keyword">default</span>, source_address=None) *使用https连接*</span><br><span class="line"></span><br><span class="line">conn.request(<span class="function"><span class="keyword">method</span>, <span class="title">url</span>, <span class="title">body</span>=<span class="title">None</span>, <span class="title">headers</span>=<span class="comment">&#123;&#125;</span>)</span><br><span class="line">*<span class="title">method</span>通常为'<span class="title">GET</span>','<span class="title">POST</span>','<span class="title">HEAD</span>','<span class="title">PUT</span>','<span class="title">DELETE</span>'；使用<span class="title">POST</span>方式时<span class="title">body</span>为<span class="title">urlencode</span>编码的字符串*</span><br><span class="line"></span><br><span class="line"><span class="title">resp</span> = <span class="title">conn</span>.<span class="title">getresponse</span><span class="params">()</span> *返回<span class="title">HTTPResponse</span>对象*</span><br><span class="line"><span class="title">resp</span>.<span class="title">read</span><span class="params">()</span> *返回<span class="title">response</span> <span class="title">body</span>*</span><br><span class="line"><span class="title">resp</span>.<span class="title">getheaders</span><span class="params">()</span> *以列表的形式返回所有的<span class="title">response</span> <span class="title">header</span>*</span><br><span class="line"><span class="title">resp</span>.<span class="title">getheader</span><span class="params">(name[, <span class="keyword">default</span>])</span> *返回指定的<span class="title">response</span> <span class="title">header</span>，没有则返回<span class="title">default</span>*</span><br><span class="line"><span class="title">resp</span>.<span class="title">status</span>, <span class="title">resp</span>.<span class="title">reason</span> *返回<span class="title">response</span> <span class="title">code</span>和<span class="title">response</span> <span class="title">reason</span>*</span></span><br></pre></td></tr></table></figure></p>
<p>httplib底层利用socket连接到web server，其提供的HTTPSConnection使用ssl模块的socket wrapper。</p>
<h2 id="httplib2">httplib2</h2><p>httplib2为第三方库(a comprehensive HTTP client library)，可以在<a href="https://pypi.python.org/pypi/httplib2" title="httplib2_link" target="_blank" rel="external">这里</a>下载。简单的使用示例如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = httplib2.<span class="type">Http</span>(cache=<span class="string">".cache"</span>, timeout=<span class="type">None</span>)</span><br><span class="line">(resp_headers, content) = h.request(url, <span class="keyword">method</span>=<span class="string">"GET"</span>, body=<span class="type">None</span>, headers=<span class="type">None</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="requests">requests</h2><p>urllib, urllib2是Python标准库中提供的module，通常需要结合使用才能完成一些基本功能，而requests提供了更简单的接口让使用HTTP不再那么复杂，它也正如其宣称的那样——HTTP for Humans，可以在<a href="http://requests-docs-cn.readthedocs.org/zh_CN/latest/index.html" title="requests_doc" target="_blank" rel="external">这里</a>查看官方文档，Package下载<a href="https://pypi.python.org/pypi/requests" title="requests_link" target="_blank" rel="external">地址</a>。</p>
<h3 id="1-_HTTP_Request">1. HTTP Request</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">requests.get/post --&gt; Session.request(method, url, ...)</span><br><span class="line">    --&gt; Session.send(req_obj) --&gt; rsp_obj=XXXAdapter.send(req_obj)</span><br><span class="line"><span class="keyword">*</span>首先根据传入的参数构造Request对象，利用不同的Adapter处理不同的Request，返回相应的Response对象<span class="keyword">*</span></span><br><span class="line"></span><br><span class="line">request(method, url, params=None, data=None, headers=None, cookies=None,</span><br><span class="line">  files=None, auth=None, timeout=None, allow_redirects=True, proxies=None,</span><br><span class="line">  hooks=None, stream=None, verify=None, cert=None)</span><br><span class="line">  <span class="keyword">*</span>params: get方法使用的查询字符串的参数，dict类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>data: post方法发送的body中的数据，dict类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>headers: 自定义HTTP头部信息，dict类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>cookies: 发送的Cookie信息，dict或CookieJar对象<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>files: 上传multipart encoded文件，文件类对象dict，如&#123;'file': open(fp,<span class="string">"rb"</span>)&#125;<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>auth: HTTP Auth，tuple类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>timeout: 超时设置秒数，仅用于连接过程，float类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>allow_redirects: 是否允许重定向，默认True<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>proxies: 代理设置，dict类型<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>stream: 是否立即下载响应内容，默认False，请求后会立即下载响应体，设置True时只返回header内容，当访问r.content时才开始下载响应体<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>verify: 是否验证主机SSL证书，默认True<span class="keyword">*</span></span><br><span class="line">  <span class="keyword">*</span>cert: 设置本地client证书<span class="keyword">*</span></span><br><span class="line">所有类型的请求都是通过调用request方法来实现，例如：</span><br><span class="line">r = requests.get(url, <span class="keyword">*</span><span class="keyword">*</span>kwargs) <span class="keyword">*</span>字典中值为None的键不会添加参数<span class="keyword">*</span></span><br><span class="line">r = requests.post(url, data=&#123;&#125;, <span class="keyword">*</span><span class="keyword">*</span>kwargs)</span><br></pre></td></tr></table></figure>
<h3 id="2-_HTTP_Response">2. HTTP Response</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">r<span class="class">.text</span>: unicode编码的response内容，会根据response header中的编码来解码，r.encoding属性可以查看当前编码，并可以指定新的编码，再执行该方法将利用新编码来解析</span><br><span class="line">r<span class="class">.content</span>: 对于非文本请求可以用byte的方式返回内容，会自动解码gzip和deflate</span><br><span class="line">r.<span class="function"><span class="title">json</span><span class="params">()</span></span>: 解码json格式的数据，解析失败会抛出异常</span><br><span class="line">r<span class="class">.raw</span>: 存放原始响应内容，需要设置stream为True，操作文本流可以使用下面的方式：</span><br><span class="line">with <span class="function"><span class="title">open</span><span class="params">(filename, <span class="string">'wb'</span>)</span></span> as fd:</span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> r.<span class="function"><span class="title">iter_content</span><span class="params">(chunk_size)</span></span>:</span><br><span class="line">        fd.<span class="function"><span class="title">write</span><span class="params">(chunk)</span></span></span><br><span class="line">r<span class="class">.status_code</span>: 响应码</span><br><span class="line">r<span class="class">.reason</span>: 返回响应信息</span><br><span class="line">r<span class="class">.headers</span>: 以dict返回响应头</span><br><span class="line">r<span class="class">.url</span>: 最终的url</span><br><span class="line">r<span class="class">.cookies</span>: 以dict返回所有的cookie </span><br><span class="line">r<span class="class">.history</span>: 返回Response list，可以追踪重定向，按时间顺序从老到新排列</span><br><span class="line">r<span class="class">.request</span>: 返回相应的request对象</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liteway/liteway.github.io/2015/06/20/py_httpclient/" data-id="cid43uja60008hgvkoup0xy0m" class="article-share-link">Share</a>
      
      
        <a href="2015/06/20/py_httpclient/#ds-thread" class="article-comment-link">comments</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/04/20/ie_cve_2012_4969/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">IE UAF漏洞分析之CVE-2012-4969</div>
    </a>
  
</nav>

  
</article>



  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2015/06/20/py_httpclient/" data-title="Python HTTP Client Lib" data-url="https://github.com/liteway/liteway.github.io/2015/06/20/py_httpclient/"></div>
  </section>


</section>
        
          
            <aside id="sidebar">
    <div class="widget-wrap fixed">
    <h3 class="widget-title">文章目录</h3>

    <div class="widget">
        <ul class='toc'>
        <li><a class='anchor' href='#logo'>Title</a></li>
        <li><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#urllib"><span class="toc-number">1.</span> <span class="toc-text">urllib</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#urllib2"><span class="toc-number">2.</span> <span class="toc-text">urllib2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#httplib"><span class="toc-number">3.</span> <span class="toc-text">httplib</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#httplib2"><span class="toc-number">4.</span> <span class="toc-text">httplib2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#requests"><span class="toc-number">5.</span> <span class="toc-text">requests</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-_HTTP_Request"><span class="toc-number">5.1.</span> <span class="toc-text">1. HTTP Request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-_HTTP_Response"><span class="toc-number">5.2.</span> <span class="toc-text">2. HTTP Response</span></a></li></ol></li></ol></li>
        <li><a class='anchor' href='#comments'>Comments</a></li> 
        </ul>
    </div>
</div>
</aside>
          
        
      </div>
      <div id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 liteway &nbsp; &nbsp;
      Powered by <a href="https://github.com/xing5/hexo-theme-codeland" target="_blank">Hexo codeland</a>
    </div>
  </div>
</div>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    
<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"liteway"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<a href="#logo" id="totop" style="display: inline;">^</a>


<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>