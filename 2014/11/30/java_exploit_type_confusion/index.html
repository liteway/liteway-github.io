<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Watching Type Confusion Attacks from Java Exploits | 骆驼的乌托邦</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文通过几个典型的Java CVE来分析几种不同的类型混淆攻击手法。由于之前写的是英文的，这里就没有再翻译为中文。">
<meta property="og:type" content="article">
<meta property="og:title" content="Watching Type Confusion Attacks from Java Exploits">
<meta property="og:url" content="https://github.com/liteway/liteway.github.io/2014/11/30/java_exploit_type_confusion/index.html">
<meta property="og:site_name" content="骆驼的乌托邦">
<meta property="og:description" content="本文通过几个典型的Java CVE来分析几种不同的类型混淆攻击手法。由于之前写的是英文的，这里就没有再翻译为中文。">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/1.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/2.0.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/2.1.png">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/2.2.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/2.3.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/2.4.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/2.5.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/2.6.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/3.0.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/3.1.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/3.2.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/3.3.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/4.0.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/4.1.jpg">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/4.2.png">
<meta property="og:image" content="https://github.com/liteway/liteway.github.io/img/java_exploit_type_confusion/4.3.jpg">
<meta property="og:updated_time" content="2015-08-08T08:48:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Watching Type Confusion Attacks from Java Exploits">
<meta name="twitter:description" content="本文通过几个典型的Java CVE来分析几种不同的类型混淆攻击手法。由于之前写的是英文的，这里就没有再翻译为中文。">
  
    <link rel="alternative" href="/atom.xml" title="骆驼的乌托邦" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico">
  
  <link href="//fonts.useso.com/css?family=Inconsolata:400,700|Open+Sans:700,400" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">骆驼的乌托邦
          
          </a>
        </h1>
      </div>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/liteway/liteway.github.io"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main"><article id="post-java_exploit_type_confusion" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/30/java_exploit_type_confusion/" class="article-date">
  <time datetime="2014-11-29T16:01:01.000Z" itemprop="datePublished">2014-11-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/漏洞分析/">漏洞分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Watching Type Confusion Attacks from Java Exploits
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文通过几个典型的Java CVE来分析几种不同的类型混淆攻击手法。由于之前写的是英文的，这里就没有再翻译为中文。<a id="more"></a></p>
<p>In recent years, Java has become a favorite target for attackers because of its huge user base and platform independence. In the common 4 categories of Java vulnerabilities (include type confusion, logic error, memory corruption and argument injection), type confusion attack is the most popular one, and this type of exploit is also widely used by some famous EKs (Exploit Kits) in the latest three years. According to the article (link: Exploit Kit Landscape of 2014), the CVE-2012-0507, a typical type confusion attack, is still active in Nuclear EK and Fiesta EK.</p>
<h2 id="Concept_of_Type_Confusion">Concept of Type Confusion</h2><p>An object’s type defines its behaviors, and a program can’t perform an operation on an object unless the object’s type defines it. The type for an object is just like the identity for one person, if the identity is stolen by an attacker, then the attacker can exploit it to access the person’s resources, similar to this, the confused object can perform the stolen type’s operations.<br>In general, type confusion means an illegal type conversion. Such as the following example, once TYPE_B is confused to TYPE_A successfully, then we can use the returned object b to call the TYPE_A’s methods, and can access the TYPE_A’s memory, that may lead to exploitation.<br><img src="/img/java_exploit_type_confusion/1.jpg" alt=""><br>Type safety is the most essential element of Java security, the Java language is designed to guarantee type safety, and it all depends on static type checking of the byte code verifier at compile time. Although the byte code verifier is an effective checker for type safety, there are some type confusion methods that can bypass Java type checking. </p>
<h2 id="Type_Confusion_Attacks_in_Java">Type Confusion Attacks in Java</h2><p>In the Java sandbox model, SecurityManager and ClassLoader are the critical types, anyone of them is confused to the crafted type that an attacker can control, which may result in Java sandbox is broken. From the perspective of confusion targets, the following will present two different kinds of type confusion attacks.</p>
<h2 id="ClassLoader_Confusion_Attack">ClassLoader Confusion Attack</h2><p>In the Java security infrastructure, class loader plays a very important role. The JVM (Java Virtual Machine) uses different class loaders to load classes from different sources, and assigns different permissions, which can isolate credible classes from evil classes. However if a crafted class loader from attacker is confused to a privileged class loader that JVM trusted, then the crafted class loader can do whatever the privileged class loader does, and this is a typical class loader confusion attack. Here we will introduce two different methods to achieve this attack with the cases CVE-2012-0507 and CVE-2012-1723.</p>
<h3 id="CVE-2012-0507_(API_Level_Confusion)">CVE-2012-0507 (API Level Confusion)</h3><p>The exploit of CVE-2012-0507 is a very typical case of type confusion attack, it confuses user defined class loader to applet class loader through Java API vulnerability. This vulnerability exists in the java.util.concurrent.atomic.AtomicReferenceArray class, the Object[] member variable allows to store any array, meanwhile the set(int i, E newValue) member method which includes the putObjectVolatile(Object o, long offset, Object x) native method implemented in sun.misc.Unsafe class, can store any type of object into the inner array without safety check. Therefore, if we can store an array A[] to the Object[], and set B as the member of A[], and then get it out as type A, now we confuse type A to type B successfully. According to this way, below we will analyze the major exploit process.</p>
<p>a)  Construct AtomicReferenceArray<br>In this case, we use Help[] as the array which will store to the private Object[] member of AtomicReferenceArray, but it doesn’t permit to set the private member by reflection in applet context. Because the AtomicReferenceArray is serializable, so we can serialize Help[] and AtomicReferenceArray to an assistant array object named arrayOfObject, then deserialize and get them out with original types. The following code shows this process.<br><img src="/img/java_exploit_type_confusion/2.0.jpg" alt=""><br>After this construction process, the arrayOfObject’s structure layout is like the following figure, arrayOfObject[0] is Help[], arrayOfObject[1] is crafted AtomicReferenceArray, the private Object[] member of AtomicReferenceArray is the reference of arrayOfObject[0].<br><img src="/img/java_exploit_type_confusion/2.1.png" alt=""></p>
<p>b)  Confuse ClassLoader<br>After get the crafted arrayOfObject, the vulnerable set method of AtomicReferenceArray can help to store localClassLoader into the array member without safety check, the immediate effect is that localClassLoader becomes the member of Help[], we can get localClassLoader out with Help type, then the localHelp is confused to localClassLoader.<br><img src="/img/java_exploit_type_confusion/2.2.jpg" alt=""><br>The Help is a serializble class that extends from ClassLoader, and we pass the confused Help object whose real type is localClassLoader to the static doWork method, then we can operate the real localClassLoader in this method.<br><img src="/img/java_exploit_type_confusion/2.3.jpg" alt=""></p>
<p>c)  Construct ProtectionDomain<br>While class loader loads a class to JVM, the relevant protection domain will be created and linked to the class. Protection domain is a set of permissions and code sources, and it decides code’s running limits in Java sandbox. Once a class’s protection domain is set to all permissions, the class can do any privileged operation. The code of creating protection domain with all permissions is as follows.<br><img src="/img/java_exploit_type_confusion/2.4.jpg" alt=""><br>For preparing a class to link to the protection domain of all permissions, we create a payload class named MyPayload and convert its content to a byte array, and we can deploy some attacking behaviors in the payload class.<br><img src="/img/java_exploit_type_confusion/2.5.jpg" alt=""></p>
<p>d)  Trigger Exploit<br>After that, the real effective confusion occurs in the defineClass method of ClassLoader. The defineClass method is the key to load a class, and we can’t access from outside because it’s a protected member method, but in the Help class which extends from ClassLoader, that will not be a problem. However, the Help class, a user defined ClassLoader, has no permission to instantiate class, but for the instantiated localClassLoader, it’s legitimate to call defineClass method.<br>In the following code, the paramHelp object that has been confused is actually the reference of localClassLoader, therefore when we call the following paramHelp.defineClass, we actually use current applet class loader to load our payload class with all permissions. Once the localClass.newInstance method is executed, the attacking behaviors in MyPayload class will be performed successfully.<br><img src="/img/java_exploit_type_confusion/2.6.jpg" alt=""></p>
<p>In summary, the root cause of CVE-2012-0507 is that the set method in AtomicReferenceArray allows the array member to store any type of object without type checking, and eventually lead to type confusion attack for class loader. </p>
<h3 id="CVE-2012-1723_(Instruction_Level_Confusion)">CVE-2012-1723 (Instruction Level Confusion)</h3><p>Be similar to CVE-2012-0507, the exploit of CVE-2012-1723 also confuses custom class loader to applet class loader, and then loads evil class through abusing defineClass method. Different from CVE-2012-0507’s type confusion in API level, it confuses type in instruction level. The vulnerability occurs in the verification phase for methods JIT(Just In Time) compiled, the field access instructions (GETSTATIC/PUTSTATIC/GETFIELD/PUTFIELD) can be abused to confuse static field and nonstatic filed. The main exploit process is as follows.</p>
<p>a)  Defer Method Verification<br>In consideration of performance, JVM usually compiles some hot code (commonly executed method or loop code block) to native machine code with JIT compilation at runtime, and the byte code verification for hot methods also will be deferred to runtime. We put the confuse method in a large loop, and call the method with null argument to ensure the real confusion instructions can’t be executed, then the confuse method will be JIT compiled, meanwhile the method verification will be deferred.<br><img src="/img/java_exploit_type_confusion/3.0.jpg" alt=""></p>
<p>b)  Confuse Field<br>For JIT method, the tactic of field verification is that if two field access instructions refer to the same field in a method, the field is only verified once and the result will be cached. Once the verification information of first field instruction is cached, the verification couldn’t be done when invoking second field instruction. Because we have no permission to instantiate a ClassLoader class, so we choose GETSTATIC and PUTFIELD to confuse a static ClassLoader to an instance field.<br><img src="/img/java_exploit_type_confusion/3.1.jpg" alt=""><br>In the code above, the staticTypeA, whose type is ClassLoader, is a static field of Confuser class. We tamper the byte code of confuse method, adding getstatic and pop in front that will make the verification information for staticTypeA cached without affecting the subsequent execution flow, and then changing original putstatic to putfield that will make JVM write the staticTypeA into one of instance fields in Confuser class. Now that the static field located in method area is confused to an instance field located in current heap.</p>
<p>c)  Search Target Field<br>Before tampering the byte code of confuse method, we need to deploy some instance fields in Confuser class as search domain. The type of instance fields is ConfusingClassLoader which is a user defined ClassLoader. If one of instance fields is matched, the paramClassLoader will be returned as ConfusingClassLoader type. The Confuser class is as follows.<br><img src="/img/java_exploit_type_confusion/3.2.jpg" alt=""></p>
<p>d)  Trigger Exploit<br>The triggering process is similar with CVE-2012-0507. In the following code, c1 is the confused applet class loader, and then call c1.defineClass to load an evil class with all permissions in the static method of ConfusingClassLoader class.<br><img src="/img/java_exploit_type_confusion/3.3.jpg" alt=""><br>Comparing with CVE-2012-0507, this vulnerability is more subtle, and the type confusion method is more skillful. But all the same, both of the two exploits are taking applet class loader as confused target, and then load evil classes to perform arbitrary code.</p>
<h2 id="System_Class_Confusion_Attack">System Class Confusion Attack</h2><p>The security manager is the core of Java sandbox, it will be awoken to check permissions when some unsafe operations try to execute. However once the security manager is set to null, the following security check could not be performed, and many Java exploits disable security manager and bypass Java sandbox in this way. For Java applet, the static SecurityManager object in java.lang.System class is set to AppletSecurity by default, if we can confuse user defined class to System class, and control the memory of System class, then directly set SecurityManager object in the memory to null, and the exploit of CVE-2013-2423 is using this attack method.</p>
<h3 id="CVE-2013-2423">CVE-2013-2423</h3><p>This vulnerability exists in the reflection API of Java 7, the findStaticSetter method can be used to tamper with any field of value. The exploit abuses findStaticSetter to tamper with the TYPE fields of Integer and Double class, then utilizes the difference of type size to confuse crafted class to System class, and the detail exploit process is as follows.</p>
<p>a)  Craft Assistant Classes<br>In order to confuse System class, we first need to craft 3 assistant classes: Union1, Union2 and SystemClass. The SystemClass as confusion class includes some objects that is used for searching SecurityManager object in memory. The structures of these classes are like the following figure.<br><img src="/img/java_exploit_type_confusion/4.0.jpg" alt=""></p>
<p>b)  Confuse System Class<br>For each Java basic type, there is a corresponding type class, such as java.lang.Integer, java.lang.Double, and the TYPE field of type class decides the type of a variable and the size of allocated space. In 32 bit JVM, the int type is 4 bytes, the double type is 8 bytes, we can confuse the size of basic type by using the vulnerable findStaticSetter method to tamper with the TYPE fields of Integer and Double. As the following code, the findStaticSetter method is used to create a method handle for setting static TYPE field, and save the original TYPE field for recovering afterward, then set Double.TYPE to Integer.TYPE while set Integer.TYPE to null, and now JVM will take int type as double type, and operate it with 8 bytes.<br><img src="/img/java_exploit_type_confusion/4.1.jpg" alt=""><br>After confusing Integer and Double, we set the field2 of Union1 to the real System.class, and get the field1 of Union1 which will lead to read 8 bytes from memory, and then when we write the 8 bytes’ data to the field1 of Union2, it will override the point of SystemClass with the point of real System.class, and now that the System.class is confused to our crafted SystemClass. The confused memory layout is like following figure.<br><img src="/img/java_exploit_type_confusion/4.2.png" alt=""></p>
<p>c)  Disable Security Manager<br>After confused successfully, we can find the static SecurityManager member of System class by matching objects of SystemClass, and then set the matched object to null. And now that the security manager of current applet is disabled, we can do any unsafe operation.<br><img src="/img/java_exploit_type_confusion/4.3.jpg" alt=""></p>
<p>In summary, type confusion breaks down the barrier of accessing memory, let illegal objects enter into restricted area and tamper with critical data, and finally lead security system to be compromised. In Java exploits of recent years, type confusion attacks occupy an import position, we can pay more attention to type safety, so as to protect system better.</p>
<p>Reference:<br>[1] <a href="http://www.securingjava.com/chapter-two/chapter-two-10.html" target="_blank" rel="external">http://www.securingjava.com/chapter-two/chapter-two-10.html</a><br>[2] <a href="http://schierlm.users.sourceforge.net/TypeConfusion.html" target="_blank" rel="external">http://schierlm.users.sourceforge.net/TypeConfusion.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liteway/liteway.github.io/2014/11/30/java_exploit_type_confusion/" data-id="cid43ujag000ihgvk1mkj1x0m" class="article-share-link">Share</a>
      
      
        <a href="2014/11/30/java_exploit_type_confusion/#ds-thread" class="article-comment-link">comments</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-CVE/">Java CVE</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/04/20/ie_cve_2012_4969/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          IE UAF漏洞分析之CVE-2012-4969
        
      </div>
    </a>
  
  
    <a href="/2014/09/18/java_cve_2012_5076/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java Exploit分析之CVE-2012-5076</div>
    </a>
  
</nav>

  
</article>



  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2014/11/30/java_exploit_type_confusion/" data-title="Watching Type Confusion Attacks from Java Exploits" data-url="https://github.com/liteway/liteway.github.io/2014/11/30/java_exploit_type_confusion/"></div>
  </section>


</section>
        
          
            <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/渗透测试/">渗透测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞分析/">漏洞分析</a><span class="category-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget recents">
      <ul>
        
          <li>
            <a href="/2015/06/20/py_httpclient/">Python HTTP Client Lib</a>
          </li>
        
          <li>
            <a href="/2015/04/20/ie_cve_2012_4969/">IE UAF漏洞分析之CVE-2012-4969</a>
          </li>
        
          <li>
            <a href="/2014/11/30/java_exploit_type_confusion/">Watching Type Confusion Attacks from Java Exploits</a>
          </li>
        
          <li>
            <a href="/2014/09/18/java_cve_2012_5076/">Java Exploit分析之CVE-2012-5076</a>
          </li>
        
          <li>
            <a href="/2014/09/14/java_cve_2012_4681/">Java Exploit分析之CVE-2012-4681</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/IE-CVE/" style="font-size: 10px;">IE CVE</a> <a href="/tags/Java-CVE/" style="font-size: 20px;">Java CVE</a> <a href="/tags/Metasploit/" style="font-size: 10px;">Metasploit</a> <a href="/tags/UAF/" style="font-size: 10px;">UAF</a> <a href="/tags/python/" style="font-size: 10px;">python</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">十一月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">九月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">八月 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
</aside>
          
        
      </div>
      <div id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 liteway &nbsp; &nbsp;
      Powered by <a href="https://github.com/xing5/hexo-theme-codeland" target="_blank">Hexo codeland</a>
    </div>
  </div>
</div>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    
<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"liteway"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<a href="#logo" id="totop" style="display: inline;">^</a>


<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>